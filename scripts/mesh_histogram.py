#!/opt/build/qgis-2.6.0/installs/python27/bin/python
import pandas as pd
import matplotlib.pyplot as plt
import os
import sys

sys.path.append('/opt/build/qgis-2.6.0/installs/qgis2/share/qgis/python/')
from qgis.core import *
from qgis.analysis import QgsGeometryAnalyzer

qgishome='/opt/build/qgis-2.6.0/installs/qgis2/'
app = QgsApplication([], True)
app.setPrefixPath(qgishome, True)
app.initQgis()

# input_directory_path
input_directory_path = "/share/CI-WATER_Simulation_Data/upper_colorado_mesh"

# This script will write its output to this directory
# the files it will write are:
#
# output_directory_path/histogram
output_directory_path = "/share/CI-WATER_Simulation_Data/upper_colorado_mesh"
mesh_name='WBNFLSnake_mesh'
#Mesh geometry (WKT) file (can be generated by the generate wkt script)
WKTpath           = os.path.join(input_directory_path, 'elements.wkt')
mesh_vector_uri = 'file:///'+WKTpath+'?type=csv&delimiter=%s&crs=USER:100000&&wktField=Polygon&spatialIndex=no&subsetIndex=no&watchFile=no'
ELEfilepath = os.path.join(input_directory_path, 'mesh.1.ele')
NODEfilepath = os.path.join(input_directory_path, 'mesh.1.node')
Zfilepath = os.path.join(input_directory_path, 'mesh.1.z')

print "Loading Element Layer"
#TODO/FIXME May not need this!!!
ele_layer = QgsVectorLayer(os.path.join(input_directory_path,'elements.shp'), 'Elements', 'ogr')
print "Loaded element layer"
if not ele_layer.isValid():
  print "NOT VALID"
  os._exit(1)

print "Analyzing mesh"
#QgsGeometryAnalyzer().dissolve(ele_layer, 'mesh_outline.shp')

geom = QgsGeometry.fromWkt('GEOMETRYCOLLECTION EMPTY')
for feature in ele_layer.getFeatures():
  geom = geom.combine(feature.geometry())


print geom.exportToWkt()

print "Finished"





def calculate_elem_geom():
  elements = pd.read_csv(ELEfilepath, sep=' ', skipinitialspace=True, comment='#', skiprows=1, names=['ID', 'V1', 'V2', 'V3', 'CatchmentNumber'], index_col=0, engine='c').dropna()
  nodes = pd.read_csv(NODEfilepath, sep=' ', skipinitialspace=True, comment='#', skiprows=1, names=['ID', 'X', 'Y', 'Z'], index_col=0, engine='c').dropna()
  zs = pd.read_csv(Zfilepath, sep=' ', skipinitialspace=True, comment='#', skiprows=1, names=['ID', 'Z'], index_col=0, engine='c').dropna()

  print "Finding verticie coordinates"

  #We want the coordinates of each verticie, name them X1,Y1,Z1; X2,Y2,Z2; X3,Y3,Z3 respectively
  #First get X Y Coordinates of each elements V1 vertex, drop the "Z" that comes with these
  v1 = nodes.loc[elements['V1']].drop(['Z'], axis=1)
  #Now look up the Z value for each of these nodes
  z1 = zs.loc[v1.index]
  #Combine them together, reset the index, and rename the columns
  v1 = pd.concat([v1, z1], axis=1).reset_index().drop(['ID'], axis=1).rename(columns={'X':'X1','Y':'Y1','Z':'Z1'})

  #Repeat for v2 and v3
  v2 = nodes.loc[elements['V2']].drop(['Z'], axis=1)
  z2 = zs.loc[v2.index]
  v2 = pd.concat([v2, z2], axis=1).reset_index().drop(['ID'], axis=1).rename(columns={'X':'X2','Y':'Y2','Z':'Z2'})

  v3 = nodes.loc[elements['V3']].drop(['Z'], axis=1)
  z3 = zs.loc[v3.index]
  v3 = pd.concat([v3, z3], axis=1).reset_index().drop(['ID'], axis=1).rename(columns={'X':'X3','Y':'Y3','Z':'Z3'})


  elements = pd.concat([elements, v1, v2, v3], axis=1)
  print "Done compiling verticies"

  print "Calculating element area"
  elements['Area'] = abs( elements['X1']*(elements['Y2']-elements['Y3']) +\
                          elements['X2']*(elements['Y3']-elements['Y1']) +\
                          elements['X3']*(elements['Y1']-elements['Y2']))/2.0
  print "Done calculating area"

  print "Calculating element normal vectors"
  #elements = elements.apply(element_norm, axis=1)
  #Vectorize these calculations, makes it faster
  #Start by calculating vectors A and B from coordinates of the element
  elements['aX'] = elements['X2']-elements['X1']
  elements['aY'] = elements['Y2']-elements['Y1']
  elements['aZ'] = elements['Z2']-elements['Z1']
  elements['bX'] = elements['X3']-elements['X1']
  elements['bY'] = elements['Y3']-elements['Y1']
  elements['bZ'] = elements['Z3']-elements['Z1']
  #Now calculate the normal vector by taking the cross product of A and B
  elements['Nx'] = elements['aY']*elements['bZ'] - elements['aZ']*elements['bY']
  elements['Ny'] = elements['aZ']*elements['bX'] - elements['aX']*elements['bZ']
  elements['Nz'] = elements['aX']*elements['bY'] - elements['aY']*elements['bX']
  #calculate the magnitude of each vector
  elements['N_mag'] = pd.np.sqrt(sum([elements['Nx']**2, elements['Ny']**2, elements['Nz']**2]))
  #Find the coordinates of the normalized unit vector
  elements['N_ux'] = elements['Nx']/elements['N_mag']
  elements['N_uy'] = elements['Ny']/elements['N_mag']
  elements['N_uz'] = elements['Nz']/elements['N_mag']
  print "Done calculating element normal vectors"

  print "Calculating element slope"
  elements['Slope'] = pd.np.arccos(elements['N_uz'])
  print "Done calculating element slope"
  #elements['Slope'] = pd.np.degrees(elements['Slope'])
  elements.to_msgpack(os.path.join(output_directory_path, 'element_geometry.msg'))

  return elements

def slope_hist(elements):
  #hitsogram output file
  output_file = os.path.join(output_directory_path, 'slope_histogram.pdf')

  slopes = elements['Slope']
  fig = plt.figure()
  bin_width = 0.01
  bin_range = pd.np.arange(slopes.min(), slopes.max() + bin_width, bin_width) 
  #print bin_range
  slopes.plot(kind='hist', bins=bin_range, log=True)
  plt.xlim(slopes.min(), slopes.max())
  plt.gca().set_xlabel("TIN Slope (radians)")
  plt.gca().set_title(mesh_name)
  #plt.xscale('log')
  fig.savefig(output_file)
 
def area_hist(elements):
  #hitsogram output file
  output_file = os.path.join(output_directory_path, 'area_histogram.pdf')


  #areas = pd.Series([feature.geometry().area() for feature in ele_layer.getFeatures()])
  areas = elements['Area']
  #Area is square meters, convert to ha
  areas = areas/10000
  #print areas
  fig = plt.figure()
  bin_width = 1
  bin_range = pd.np.arange(areas.min(), areas.max() + bin_width, bin_width) 
  #bin_range = pd.np.linspace(areas.min(), areas.max(), 10)
  #print bin_range
  areas.plot(kind='hist', bins=bin_range, log=True)
  plt.xlim(areas.min(), areas.max())
  plt.gca().set_xlabel("Area (ha)")
  plt.gca().set_title(mesh_name)
  #plt.xscale('log')
  fig.savefig(output_file)

read_geom = True
if __name__ == "__main__FIXME":
  if read_geom:
    elements = pd.read_msgpack((os.path.join(output_directory_path, 'element_geometry.msg')))
  else:
    elements = calculate_elem_geom()
  #print "Creating element area histogram"
  #area_hist(elements)
  print "Creating element slope histogram"
  slope_hist(elements)


#app.exitQgis()
