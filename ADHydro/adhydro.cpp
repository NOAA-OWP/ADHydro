#include "adhydro.h"
#include "all.h"
#include <netcdf.h>

void ADHydro::setLoadBalancingToManual(void)
{
  TurnManualLBOn();
}

ADHydro::ADHydro(CkArgMsg* msg)
{
  bool error = false; // Error flag.
  
  // Print usage message if number of arguments is incorrect or first argument is any flag.
  if (!(3 == msg->argc && '-' != msg->argv[1][0]))
    {
      CkPrintf("\nUsage:\n\nadhydro <input directory> <output directory>\n\n");
      CkPrintf("E.g.:\n\nadhydro ../input/mesh.1 ../output/mesh.1/run_1\n\n");
      error = true;
    }
  
  // Read input NetCDF files.
  if (!error)
    {
      currentTime = 0.0;
      endTime     = 900.0;
      dt          = 1.0;
      iteration   = 1;
      
      fileManagerProxy = CProxy_FileManager::ckNew();

      fileManagerProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(ADHydro, inputFilesOpened), thisProxy));

      // FIXME how to decide which groups to open in input files?  Right now default to 0.
      fileManagerProxy.openFiles(strlen(msg->argv[1]) + 1, msg->argv[1], 0, 0, FILE_MANAGER_READ, 0, FILE_MANAGER_READ, 0, FILE_MANAGER_READ, 0);
    }
  
  // Delete command line argument message.
  delete msg;
  
  if (error)
    {
      CkExit();
    }
}

ADHydro::ADHydro(CkMigrateMessage* msg)
{
  // Do nothing.
}

void ADHydro::pup(PUP::er &p)
{
  p | meshProxySize;
  p | meshProxy;
  p | fileManagerProxy;
  p | currentTime;
  p | endTime;
  p | dt;
  p | iteration;
}

void ADHydro::inputFilesOpened()
{
  meshProxySize = fileManagerProxy.ckLocalBranch()->numberOfMeshElements;

  meshProxy = CProxy_MeshElement::ckNew(fileManagerProxy, meshProxySize);

  meshProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(ADHydro, inputFilesRead), thisProxy));
}

void ADHydro::inputFilesRead()
{
  fileManagerProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(ADHydro, filesClosed), thisProxy));

  fileManagerProxy.closeFiles();
  
#if (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_INVARIANTS)
  checkInvariant();
#else
  // checkInvariant will result in a callback to doTimestep when finished.  If we are not checking the invariant just call the callback.
  doTimestep();
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_INVARIANTS)
}

void ADHydro::filesClosed()
{
  // Do nothing.  Don't need to wait for files to be closed.
}

void ADHydro::doTimestep()
{
  if (endTime > currentTime)
    {
      if (endTime - currentTime < dt)
        {
          dt = endTime - currentTime;
        }
      
      CkPrintf("currentTime = %lf, dt = %lf, iteration = %d\n", currentTime, dt, iteration);
      
      meshProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(ADHydro, timestepDone), thisProxy));
          
      meshProxy.doTimestep(iteration, dt);
    }
  else
    {
      CkPrintf("currentTime = %lf, simulation finished\n", currentTime);
      CkExit();
    }
}

void ADHydro::timestepDone(double dtNew)
{
#if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
  if (!(0.0 < dtNew))
    {
      CkError("ERROR in ADHydro::doTimestep: dtNew must be greater than zero.\n");
      CkExit();
    }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
  
  currentTime += dt;
  dt           = dtNew;
  iteration++;
  
  // Load balance once after a few iterations to generate load statistics.
  if (5 == iteration)
    {
      CkStartLB();
    }
  
#if (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_INVARIANTS)
  checkInvariant();
#else
  // checkInvariant will result in a callback to doTimestep when finished.  If we are not checking the invariant just call the callback.
  doTimestep();
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_INVARIANTS)
}

int ADHydro::meshProxySize;

void ADHydro::checkInvariant()
{
  bool error = false; // Error flag.
  
  if (!(0 < meshProxySize))
    {
      CkError("ERROR in ADHydro::checkInvariant: meshProxySize must be greater than zero.\n");
      error = true;
    }
  
  if (!(currentTime <= endTime))
    {
      CkError("ERROR in ADHydro::checkInvariant: currentTime must be less than or equal to endTime.\n");
      error = true;
    }
  
  if (!(0.0 < dt))
    {
      CkError("ERROR in ADHydro::checkInvariant: dt must be greater than zero.\n");
      error = true;
    }
  
  if (!error)
    {
      meshProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(ADHydro, doTimestep), thisProxy));
      
      meshProxy.checkInvariant();
    }
  else
    {
      CkExit();
    }
}

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wunused-variable"
#include "adhydro.def.h"
#pragma GCC diagnostic warning "-Wunused-variable"
