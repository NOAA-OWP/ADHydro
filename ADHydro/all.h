#ifndef __ALL_H__
#define __ALL_H__

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wsign-compare"
#include <charm++.h>
#pragma GCC diagnostic warning "-Wsign-compare"

// Error checking, assertions, and invariants
//
// Error checking is the process of checking for invalid input.  Even bug free
// code needs to perform error checking because the code cannot control what it
// is given for input.  Code should handle invalid input gracefully.  Ideally
// it should not crash or seg fault on any input and should print a helpful
// error message.
// 
// Assertions check within the code for things that the code should be
// guaranteeing to be true.  By definition, bug free code will never fire an
// assertion on any input.  This code does not satisfy that condition if any
// error checking is turned off.  Assertions are only needed for finding bugs
// and can be compiled out of production code.
// 
// Invariants are conditions that should always be true.  Invariants are
// usually written on complex data structures like a mesh or chanel network.
// Invariants can be used for both error checking and assertions.  For example,
// when reading in a mesh the code may check the invariant and throw an error
// if the input mesh does not satisfy the invariant.  Thereafter, the code may
// continue to check the invariant periodically as an assertion.
// 
// After error checking and assertions the rest of the code is written assuming
// that those checks pass.  For example, if statement cases may be omitted if
// they would be forbidden by an assertion.
#define DEBUG_LEVEL_LIBRARY_ERRORS               (1 << 0) // Error checking of return values of library calls.
#define DEBUG_LEVEL_USER_INPUT_SIMPLE            (1 << 1) // Error checking of simple conditions on user inputs.
#define DEBUG_LEVEL_USER_INPUT_INVARIANTS        (1 << 2) // Error checking of invariants        on user inputs.
#define DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE      (1 << 3) // Error checking of simple conditions on inputs to public  functions.
#define DEBUG_LEVEL_PUBLIC_FUNCTIONS_INVARIANTS  (1 << 4) // Error checking of invariants        on inputs to public  functions.
#define DEBUG_LEVEL_PRIVATE_FUNCTIONS_SIMPLE     (1 << 5) // Assertion      of simple conditions on inputs to private functions.
#define DEBUG_LEVEL_PRIVATE_FUNCTIONS_INVARIANTS (1 << 6) // Assertion      of invariants        on inputs to private functions.
#define DEBUG_LEVEL_INTERNAL_SIMPLE              (1 << 7) // Assertion      of simple conditions within the code.
#define DEBUG_LEVEL_INTERNAL_INVARIANTS          (1 << 8) // Assertion      of invariants        within the code.

// No error checking or assertions.  Not recommended.
#define DEBUG_LEVEL_NONE (0)

// This is an appropriate debug level for production code released as an executable program.
#define DEBUG_LEVEL_PRODUCTION_EXECUTABLE (DEBUG_LEVEL_LIBRARY_ERRORS | DEBUG_LEVEL_USER_INPUT_SIMPLE | DEBUG_LEVEL_USER_INPUT_INVARIANTS)

// This is an appropriate debug level for production code released as a library.
#define DEBUG_LEVEL_PRODUCTION_LIBRARY (DEBUG_LEVEL_LIBRARY_ERRORS | DEBUG_LEVEL_USER_INPUT_SIMPLE | DEBUG_LEVEL_USER_INPUT_INVARIANTS | \
                                        DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE | DEBUG_LEVEL_PUBLIC_FUNCTIONS_INVARIANTS)

// This is an appropriate debug level for development code.
#define DEBUG_LEVEL_DEVELOPMENT (DEBUG_LEVEL_LIBRARY_ERRORS | DEBUG_LEVEL_USER_INPUT_SIMPLE | DEBUG_LEVEL_USER_INPUT_INVARIANTS |                       \
                                 DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE | DEBUG_LEVEL_PUBLIC_FUNCTIONS_INVARIANTS | DEBUG_LEVEL_PRIVATE_FUNCTIONS_SIMPLE | \
                                 DEBUG_LEVEL_INTERNAL_SIMPLE | DEBUG_LEVEL_INTERNAL_INVARIANTS)

// This debug level is paranoid and expensive, but could help localize bugs.
#define DEBUG_LEVEL_ALL (DEBUG_LEVEL_LIBRARY_ERRORS | DEBUG_LEVEL_USER_INPUT_SIMPLE | DEBUG_LEVEL_USER_INPUT_INVARIANTS |                       \
                         DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE | DEBUG_LEVEL_PUBLIC_FUNCTIONS_INVARIANTS | DEBUG_LEVEL_PRIVATE_FUNCTIONS_SIMPLE | \
                         DEBUG_LEVEL_PRIVATE_FUNCTIONS_INVARIANTS | DEBUG_LEVEL_INTERNAL_SIMPLE | DEBUG_LEVEL_INTERNAL_INVARIANTS)

// Set this macro to the debug level to use.
#define DEBUG_LEVEL (DEBUG_LEVEL_DEVELOPMENT)

// Constants.
#define GRAVITY               (9.81)      // Meters per second squared.
#define POLAR_RADIUS_OF_EARTH (6356752.3) // Meters.
#define ZERO_C_IN_KELVIN      (273.15)    // Kelvin.
#define PONDED_DEPTH          (0.01)      // Meters.  Water can be ponded due to micro-topography.  Surfacewater depth below this will have no flow.

// Using NetCDF parallel collective I/O with Charm++ causes a problematic
// interaction.  Setting this flag causes a workaround to be used.  See the
// comment of FileManager::resizeUnlimitedDimensions in file_manager.h for more
// details.
// I think I figured out what was going on and it was a problem in my code.
// Remove this after verifying it works okay on Mt Moran and Yellowstone.
//#define NETCDF_COLLECTIVE_IO_WORKAROUND

// Special cases of element boundaries.
enum BoundaryConditionEnum
{
  NOFLOW  = -1, // This must be -1 because Triangle and TauDEM both use -1 to indicate no neighbor.
  INFLOW  = -2, // Others must be non-positive because positive numbers are used for neighbor array indices.
  OUTFLOW = -3
};

// Returns: true if x is a boundary condition code, false otherwise.
inline bool isBoundary(int x)
{
  return (NOFLOW == x || INFLOW == x || OUTFLOW == x);
}

// Flags to indicate how to interact with neighbors.
enum InteractionEnum
{
  I_CALCULATE_FLOW_RATE,
  NEIGHBOR_CALCULATES_FLOW_RATE,
  BOTH_CALCULATE_FLOW_RATE,
};

PUPbytes(InteractionEnum);

// Flags to indicate whether flow rate variables have been updated.
enum FlowRateReadyEnum
{
  FLOW_RATE_NOT_READY,
  FLOW_RATE_CALCULATED,
  FLOW_RATE_LIMITING_CHECK_DONE,
};

PUPbytes(FlowRateReadyEnum);

// Used for the type of channel links.
enum ChannelTypeEnum
{
  NOT_USED                           = 0, // Not all link numbers are used.
  STREAM                             = 1, // Stream link.
  WATERBODY                          = 2, // Waterbody link.
  ICEMASS                            = 3, // Equivalent to WATERBODY, but made of ice.
  PRUNED_STREAM                      = 4, // A pruned link was once used but is no longer needed.
};

PUPbytes(ChannelTypeEnum);

// Utility functions for near equality testing of doubles. Two doubles are
// considered near equal if they are within epsilon.  Epsilon is the larger of
// 10^-10 or ten orders of magnitude smaller than the number being checked
// because large doubles might have less resolution than ten digits past the
// decimal point, but they will always have ten significant digits.

// Returns: the epsilon value to use for near-equality testing with x.
inline double epsilon(double x)
{
  double eps = 1.0e-10;
  
  // Don't use library fabs and max to avoid including headers in all.h.
  if (0.0 > x)
    {
      x *= -1;
    }
  
  if (1.0 < x)
    {
      eps *= x;
    }
  
  return eps;
}

// Returns: true if a is less than and not near equal to b, false otherwise.
inline bool epsilonLess(double a, double b)
{
  return a < b - epsilon(b);
}

// Returns: true if a is greater than and not near equal to b, false otherwise.
inline bool epsilonGreater(double a, double b)
{
  return a > b + epsilon(b);
}

// Returns: true if a is less than or near equal to b, false otherwise.
inline bool epsilonLessOrEqual(double a, double b)
{
  return !epsilonGreater(a, b);
}

// Returns: true if a is greater than or near equal to b, false otherwise.
inline bool epsilonGreaterOrEqual(double a, double b)
{
  return !epsilonLess(a, b);
}

// Returns: true if a is near equal to b, false otherwise.
inline bool epsilonEqual(double a, double b)
{
  return !epsilonLess(a, b) && !epsilonGreater(a, b);
}

// Utility functions for near equality testing of floats.  Same as the
// functions for doubles, but using 10^-6 for epsilon instead of 10^-10.

// Returns: the epsilon value to use for near-equality testing with x.
inline float epsilon(float x)
{
  float eps = 1.0e-6f;
  
  // Don't use library fabs and max to avoid including headers in all.h.
  if (0.0 > x)
    {
      x *= -1;
    }
  
  if (1.0 < x)
    {
      eps *= x;
    }
  
  return eps;
}

// Returns: true if a is less than and not near equal to b, false otherwise.
inline bool epsilonLess(float a, float b)
{
  return a < b - epsilon(b);
}

// Returns: true if a is greater than and not near equal to b, false otherwise.
inline bool epsilonGreater(float a, float b)
{
  return a > b + epsilon(b);
}

// Returns: true if a is less than or near equal to b, false otherwise.
inline bool epsilonLessOrEqual(float a, float b)
{
  return !epsilonGreater(a, b);
}

// Returns: true if a is greater than or near equal to b, false otherwise.
inline bool epsilonGreaterOrEqual(float a, float b)
{
  return !epsilonLess(a, b);
}

// Returns: true if a is near equal to b, false otherwise.
inline bool epsilonEqual(float a, float b)
{
  return !epsilonLess(a, b) && !epsilonGreater(a, b);
}

// Utility functions for converting dates.

// Convert Gregorian date to Julian date.
//
// Gregorian dates are specified as year, month, day, hour, minute, second.
// A Gregorian day runs from midnight to the following midnight.
// Julian dates are specified as time in days, including fractional day, since
// noon, January 1, 4713 BCE.
// A Julian day runs from noon to the following noon.
//
// This function does not work for years before 1 CE.
//
// Copied from algorithm 199 in Collected algorithms of the CACM.
// Author: Robert G. Tantzen, Translator: Nat Howard
// Modified by RCS 10/14 for coding standards.
//
// Returns: the Julian date equal to the input Gregorian date.
//
// Parameters:
//
// year   - Gregorian year.  You must include the full year number.
//          E.g. 14 is 14 CE, not 2014 CE.  Must be positive.
// month  - Gregorian month, 1 to 12.
// day    - Gregorian day, 1 to 31.
// hour   - Gregorian hour, 0 to 23.
// minute - Gregorian minute, 0 to 59.
// second - Gregorian second including fractional second, 0 to 59.999999...
inline double gregorianToJulian(long year, long month, long day, long hour, long minute, double second)
{
  long   century;              // Number of centuries.
  long   yearInCentury;        // Tens and ones digit of the year, 0 to 99.
  long   julianDay;            // Julian day not including fractional day.
  double secondsSinceMidnight; // Number of seconds since midnight, 0.0 to 24.0 * 3600.0.

#if (DEBUG_LEVEL & DEBUG_LEVEL_PRIVATE_FUNCTIONS_SIMPLE)
  // FIXME can't link non-charm programs with CkAssert
  //CkAssert(1 <= year && 1 <= month && 12 >= month && 1 <= day && 31 >= day && 0 <= hour && 59 >= hour && 0 <= minute && 59 >= minute && 0.0 <= second &&
  //         60.0 > second);
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_PRIVATE_FUNCTIONS_SIMPLE)
  
  if (month > 2)
    {
      month -= 3L;
    }
  else
    {
      month += 9L;
      year--;
    }

  century              = year / 100L;
  yearInCentury        = year - (century * 100L);
  julianDay            = (146097L * century) / 4L + (1461L * yearInCentury) / 4L + (153L * month + 2L) / 5L + day + 1721119L;
  secondsSinceMidnight = hour * 3600.0 + minute * 60.0 + second;

  if (secondsSinceMidnight < 12.0 * 3600.0)
    {
      secondsSinceMidnight += 12.0 * 3600.0;
      julianDay--;
    }
  else
    {
      secondsSinceMidnight -= 12.0 * 3600.0;
    }

  return (julianDay + secondsSinceMidnight / (24.0 * 3600.0));
}

// Convert Julian date to Gregorian date.
//
// Julian dates are specified as time in days, including fractional day, since
// noon, January 1, 4713 BCE.
// A Julian day runs from noon to the following noon.
// Gregorian dates are specified as year, month, day, hour, minute, second.
// A Gregorian day runs from midnight to the following midnight.
//
// This function does not work for years before 1 CE.
//
// Copied from algorithm 199 in Collected algorithms of the CACM.
// Author: Robert G. Tantzen, Translator: Nat Howard
// Modified by FLO 4/99 to account for nagging round off error.
// Modified by RCS 10/14 for coding standards.
//
// Parameters:
//
// julian - Julian date.
// year   - Scalar passed by reference will be filled in with Gregorian year.
// month  - Scalar passed by reference will be filled in with Gregorian month,
//          1 to 12.
// day    - Scalar passed by reference will be filled in with Gregorian day,
//          1 to 31.
// hour   - Scalar passed by reference will be filled in with Gregorian hour,
//          0 to 23.
// minute - Scalar passed by reference will be filled in with Gregorian minute,
//          0 to 59.
// second - Scalar passed by reference will be filled in with Gregorian second
//          including fractional second, 0 to 59.999999...
inline void julianToGregorian(double julian, long* year, long* month, long* day, long* hour, long* minute, double* second)
{
  long   julianDay     = (long)julian;       // Julian day not including fractional day.
  double fractionalDay = julian - julianDay; // Fractional day since noon.

  if (fractionalDay >= 0.5)
    {
      fractionalDay -= 0.5;
      julianDay++;
    }
  else
    {
      fractionalDay += 0.5;
    }

  julianDay -= 1721119L;
  *year      = (4L * julianDay - 1L) / 146097L;
  julianDay  = 4L * julianDay - 1L - 146097L * *year;
  *day       = julianDay / 4L;
  julianDay  = (4L * *day + 3L) / 1461L;
  *day       = 4L * *day + 3L - 1461L * julianDay;
  *day       = (*day + 4L) / 4L;
  *month     = (5L * *day - 3L) / 153L;
  *day       = 5L * *day - 3 - 153L * *month;
  *day       = (*day + 5L) / 5L;
  *year      = 100L * *year + julianDay;

  if (*month < 10)
    {
      *month += 3;
    }
  else
    {
      *month -= 9;
      (*year)++;
    }

  *second  = fractionalDay * 24.0 * 3600.0;
  *hour    = (long) (*second / 3600.0);
  *second -= *hour * 3600.0;
  *minute  = (long) (*second / 60.0);
  *second -= *minute * 60.0;

#if (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
  // FIXME can't link non-charm programs with CkError and CkAssert
  //if (1 > year)
  //  {
  //    CkError("WARNING in julianToGregorian: date conversion does not work properly for years before 1 CE.\n");
  //  }
  //
  //CkAssert(1 <= *month && 12 >= *month && 1 <= *day && 31 >= *day && 0 <= *hour && 59 >= *hour && 0 <= *minute && 59 >= *minute && 0.0 <= *second &&
  //         60.0 > *second);
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
}

#endif // __ALL_H__
