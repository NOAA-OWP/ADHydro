// FIXME document communication pattern here?
module channel_element
{
  array [1D] ChannelElement
  {
    entry ChannelElement();
    
    // Dummy function for structured dagger infinite loop.
    entry void runForever()
    {
      when initialize(CProxy_MeshElement meshProxyInit, CProxy_FileManager fileManagerProxyInit)
      {
        serial
        {
          handleInitialize(meshProxyInit, fileManagerProxyInit);
        }
      }
      
      while(!allInitialized())
      {
        case
        {
          when initializeChannelNeighbor(int neighbor, int neighborReciprocalEdge, double neighborZBank, double neighborZBed,
                                         double neighborLength, ChannelTypeEnum neighborChannelType, double neighborBaseWidth,
                                         double neighborSideSlope, double neighborManningsN)
          {
            serial
            {
              handleInitializeChannelNeighbor(neighbor, neighborReciprocalEdge, neighborZBank, neighborZBed, neighborLength, neighborChannelType,
                                              neighborBaseWidth, neighborSideSlope, neighborManningsN);
            }
          }
          
          when initializeMeshNeighbor(int neighbor, int neighborReciprocalEdge, double neighborX, double neighborY, double neighborZSurface,
                                      double neighborZBedrock, double neighborSlopeX, double neighborSlopeY)
          {
            serial
            {
              handleInitializeMeshNeighbor(neighbor, neighborReciprocalEdge, neighborX, neighborY, neighborZSurface, neighborZBedrock, neighborSlopeX,
                                           neighborSlopeY);
            }
          }
        }
      }
      
      // The element must receive one forcing data message as part of initialization.  Then new forcing data can optionally arrive between timesteps.
      when forcingDataMessage()
      {
        serial
        {
          handleForcingDataMessage();
        }
      }
      
      while(true)
      {
        case
        {
          // The element must receive one forcing data message as part of initialization.  Then new forcing data can optionally arrive between timesteps.
          when forcingDataMessage()
          {
            serial
            {
              handleForcingDataMessage();
            }
          }
          
          when doTimestep(CMK_REFNUM_TYPE iterationThisTimestep, double dtThisTimestep)
          {
            serial
            {
              handleDoTimestep(iterationThisTimestep, dtThisTimestep);
            }
            
            while (!groundwaterDone)
            {
              case
              {
                when meshGroundwaterStateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth,
                                                                        double neighborGroundwaterHead)
                {
                  serial
                  {
                    handleMeshGroundwaterStateMessage(iterationThisMessage, edge, neighborSurfacewaterDepth, neighborGroundwaterHead);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when meshGroundwaterStateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth,
                                                                            double neighborGroundwaterHead)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterStateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth,
                                                                            double neighborGroundwaterHead)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterStateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth,
                                                                            double neighborGroundwaterHead)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterFlowRateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    handleMeshGroundwaterFlowRateMessage(iterationThisMessage, edge, edgeGroundwaterFlowRate);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when meshGroundwaterFlowRateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterFlowRateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterFlowRateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshGroundwaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshGroundwaterFlowRateLimitedMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                  double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    handleMeshGroundwaterFlowRateLimitedMessage(iterationThisMessage, edge, edgeGroundwaterFlowRate);
                  }
                }
                
                // Flow rate limited messages can never be unneeded so no need to discard stale messages.
              } // End case within while (!groundwaterDone).
            } // End while (!groundwaterDone).
                
            while (!surfacewaterDone)
            {
              case
              {
                when calculateSurfacewaterBoundaryConditionsMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage)
                {
                  serial
                  {
                    handleCalculateSurfacewaterBoundaryConditionsMessage(iterationThisMessage);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when calculateSurfacewaterBoundaryConditionsMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale calculateSurfacewaterBoundaryConditionsMessage "
                             "for iteration %d.\n", thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when calculateSurfacewaterBoundaryConditionsMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale calculateSurfacewaterBoundaryConditionsMessage "
                             "for iteration %d.\n", thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when calculateSurfacewaterBoundaryConditionsMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale calculateSurfacewaterBoundaryConditionsMessage "
                             "for iteration %d.\n", thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterStateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    handleChannelSurfacewaterStateMessage(iterationThisMessage, edge, neighborSurfacewaterDepth);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when channelSurfacewaterStateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterStateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterStateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterStateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    handleMeshSurfacewaterStateMessage(iterationThisMessage, edge, neighborSurfacewaterDepth);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when meshSurfacewaterStateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterStateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterStateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterStateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterFlowRateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    handleChannelSurfacewaterFlowRateMessage(iterationThisMessage, edge, edgeSurfacewaterFlowRate);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when channelSurfacewaterFlowRateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                   double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterFlowRateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                   double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterFlowRateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                   double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale channelSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterFlowRateMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    handleMeshSurfacewaterFlowRateMessage(iterationThisMessage, edge, edgeSurfacewaterFlowRate);
                  }
                }
                
                // Discard unneeded stale messages.  There is no way to receive messages whose reference number is not equal to a given number so instead we
                // receive any message whose reference number is equal to the past three timesteps.
                when meshSurfacewaterFlowRateMessage[iterationThisTimestep - 1](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterFlowRateMessage[iterationThisTimestep - 2](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when meshSurfacewaterFlowRateMessage[iterationThisTimestep - 3](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    CkPrintf("NOTE: channel element %d, iteration %d: Discarding unneeded stale meshSurfacewaterFlowRateMessage for iteration %d.\n",
                             thisIndex, iterationThisTimestep, iterationThisMessage);
                  }
                }
                
                when channelSurfacewaterFlowRateLimitedMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                      double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    handleChannelSurfacewaterFlowRateLimitedMessage(iterationThisMessage, edge, edgeSurfacewaterFlowRate);
                  }
                }
                
                // Flow rate limited messages can never be unneeded so no need to discard stale messages.
                
                when meshSurfacewaterFlowRateLimitedMessage[iterationThisTimestep](CMK_REFNUM_TYPE iterationThisMessage, int edge,
                                                                                   double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    handleMeshSurfacewaterFlowRateLimitedMessage(iterationThisMessage, edge, edgeSurfacewaterFlowRate);
                  }
                }
                
                // Flow rate limited messages can never be unneeded so no need to discard stale messages.
              } // End case within while (!surfacewaterDone).
            } // End while (!surfacewaterDone).
          } // End when doTimestep(CMK_REFNUM_TYPE iterationThisTimestep, double dtThisTimestep).
          
          when updateState()
          {
            serial
            {
              // FIXME rather than requiring a separate message to tell the element to send its state to the file manager we could have an extra parameter to
              // the DoTimestep message that tells it to send its state to the file manager as soon as the timestep is done.
              fileManagerProxy[FileManager::home(thisIndex, fileManagerProxy.ckLocalBranch()->globalNumberOfChannelElements)]
                  .channelStateMessage(thisIndex, surfacewaterDepth, surfacewaterError);
            }
          }
          
          when checkInvariant()
          {
            serial
            {
              handleCheckInvariant();
            }
            
            while(!allInvariantChecked())
            {
              case
              {
                when checkChannelNeighborInvariant(int neighbor, int edge, int neighborEdge, InteractionEnum neighborInteraction, double neighborZBank,
                                                   double neighborZBed, double neighborLength, double neighborChannelType, double neighborBaseWidth,
                                                   double neighborSideSlope, double neighborManningsN, double neighborSurfacewaterFlowRate,
                                                   double neighborSurfacewaterCumulativeFlow, double neighborDt)
                {
                  serial
                  {
                    handleCheckChannelNeighborInvariant(neighbor, edge, neighborEdge, neighborInteraction, neighborZBank, neighborZBed, neighborLength,
                                                        neighborChannelType, neighborBaseWidth, neighborSideSlope, neighborManningsN,
                                                        neighborSurfacewaterFlowRate, neighborSurfacewaterCumulativeFlow, neighborDt);
                  }
                }
                
                when checkMeshNeighborInvariant(int neighbor, int edge, int neighborEdge, InteractionEnum neighborInteraction, double neighborX,
                                                double neighborY, double neighborZSurface, double neighborZBedrock, double neighborZOffset,
                                                double neighborSlopeX, double neighborSlopeY, double neighborEdgeLength,
                                                double neighborSurfacewaterFlowRate, double neighborSurfacewaterCumulativeFlow,
                                                double neighborGroundwaterFlowRate, double neighborGroundwaterCumulativeFlow, double neighborDt)
                {
                  serial
                  {
                    handleCheckMeshNeighborInvariant(neighbor, edge, neighborEdge, neighborInteraction, neighborX, neighborY, neighborZSurface,
                                                     neighborZBedrock, neighborZOffset, neighborSlopeX, neighborSlopeY, neighborEdgeLength,
                                                     neighborSurfacewaterFlowRate, neighborSurfacewaterCumulativeFlow, neighborGroundwaterFlowRate,
                                                     neighborGroundwaterCumulativeFlow, neighborDt);
                  }
                }
              } // End case within while(!allNeighborInvariantChecked())
            } // End while(!allNeighborInvariantChecked())
            
            serial
            {
              contribute();
            }
          } // End when checkInvariant()
        } // End case within while(true).
      } // End while(true).
    }; // End entry void runForever().
    
    entry void initialize(CProxy_MeshElement meshProxyInit, CProxy_FileManager fileManagerProxyInit);
    entry void initializeChannelNeighbor(int neighbor, int neighborReciprocalEdge, double neighborZBank, double neighborZBed,
                                         double neighborLength, ChannelTypeEnum neighborChannelType, double neighborBaseWidth,
                                         double neighborSideSlope, double neighborManningsN);
    entry void initializeMeshNeighbor(int neighbor, int neighborReciprocalEdge, double neighborX, double neighborY, double neighborZSurface,
                                      double neighborZBedrock, double neighborSlopeX, double neighborSlopeY);
    entry void forcingDataMessage();
    entry void doTimestep(CMK_REFNUM_TYPE iterationThisTimestep, double dtThisTimestep);
    entry void meshGroundwaterStateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth, double neighborGroundwaterHead);
    entry void meshGroundwaterFlowRateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate);
    entry void meshGroundwaterFlowRateLimitedMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeGroundwaterFlowRate);
    entry void calculateSurfacewaterBoundaryConditionsMessage(CMK_REFNUM_TYPE iterationThisMessage);
    entry void channelSurfacewaterStateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth);
    entry void meshSurfacewaterStateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double neighborSurfacewaterDepth);
    entry void channelSurfacewaterFlowRateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate);
    entry void meshSurfacewaterFlowRateMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate);
    entry void channelSurfacewaterFlowRateLimitedMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate);
    entry void meshSurfacewaterFlowRateLimitedMessage(CMK_REFNUM_TYPE iterationThisMessage, int edge, double edgeSurfacewaterFlowRate);
    entry void updateState();
    entry void checkInvariant();
    entry void checkChannelNeighborInvariant(int neighbor, int edge, int neighborEdge, InteractionEnum neighborInteraction, double neighborZBank,
                                             double neighborZBed, double neighborLength, double neighborChannelType, double neighborBaseWidth,
                                             double neighborSideSlope, double neighborManningsN, double neighborSurfacewaterFlowRate,
                                             double neighborSurfacewaterCumulativeFlow, double neighborDt);
    entry void checkMeshNeighborInvariant(int neighbor, int edge, int neighborEdge, InteractionEnum neighborInteraction, double neighborX,
                                          double neighborY, double neighborZSurface, double neighborZBedrock, double neighborZOffset,
                                          double neighborSlopeX, double neighborSlopeY, double neighborEdgeLength,
                                          double neighborSurfacewaterFlowRate, double neighborSurfacewaterCumulativeFlow,
                                          double neighborGroundwaterFlowRate, double neighborGroundwaterCumulativeFlow, double neighborDt);
  }; // End array [1D] ChannelElement.
}; // End module channel_element.
