module file_manager
{
  group FileManager
  {
    entry FileManager();
    
    // Dummy function for structured dagger infinite loop.
    entry void runForever()
    {
      // The file manager must receive exactly one type of initialization message first.
      case
      {
        when initializeFromASCIIFiles(size_t directorySize, const char directory[directorySize], size_t fileBasenameSize,
                                      const char fileBasename[fileBasenameSize])
        {
          serial
          {
            handleInitializeFromASCIIFiles(directory, fileBasename);
          }
        }
        
        when initializeFromNetCDFFiles(size_t directorySize, const char directory[directorySize])
        {
          serial
          {
            handleInitializeFromNetCDFFiles(directory);
          }
        }
      }
      
      // Calculating derived values may require getting vertex data from other file managers.
      serial
      {
        updateVertices();
      }
      
      // If it is not required allVerticesUpdated will immediately return true.
      while (!allVerticesUpdated())
      {
        case
        {
          when meshVertexDataMessage(int element, int vertex, double x, double y, double zSurface)
          {
            serial
            {
              handleMeshVertexDataMessage(element, vertex, x, y, zSurface);
            }
          }
          
          when channelVertexDataMessage(int element, int vertex, double x, double y, double zBank)
          {
            serial
            {
              handleChannelVertexDataMessage(element, vertex, x, y, zBank);
            }
          }
        }
      }
      
      // Then the file manager must calculate derived values.
      serial
      {
        calculateDerivedValues();
      }
      
      // Then the file manager must create the output files.
      when createFiles(size_t directorySize, const char directory[directorySize])
      {
        serial
        {
          handleCreateFiles(directory);
        }
      }
      
      // Then the file manager must write the initial state into the output files.
      when writeFiles(size_t directorySize, const char directory[directorySize], bool writeGeometry, bool writeParameter, bool writeState)
      {
        serial
        {
          handleWriteFiles(directory, writeGeometry, writeParameter, writeState);
        }
      }
      
      // Then the file manager must read forcing data as part of initialization.
      when readForcingData(size_t directorySize, const char directory[directorySize], CProxy_MeshElement meshProxy, CProxy_ChannelElement channelProxy,
                           double referenceDate, double currentTime)
      {
        serial
        {
          handleReadForcingData(directory, meshProxy, channelProxy, referenceDate, currentTime);
        }
      }
      
      while (true)
      {
        case
        {
          // After receiving an initial forcing data message new forcing data messages can optionally arrive between timesteps.
          when readForcingData(size_t directorySize, const char directory[directorySize], CProxy_MeshElement meshProxy, CProxy_ChannelElement channelProxy,
                               double referenceDate, double currentTime)
          {
            serial
            {
              handleReadForcingData(directory, meshProxy, channelProxy, referenceDate, currentTime);
            }
          }
          
          // Update state messages can also optionally arrive between timesteps.
          when updateState(double referenceDateNew, double currentTimeNew, double dtNew, size_t iterationNew)
          {
            serial
            {
              handleUpdateState(referenceDateNew, currentTimeNew, dtNew, iterationNew);
            }
            
            while (!allElementsUpdated())
            {
              case
              {
                when meshStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double groundwaterHead, double groundwaterError,
                                      double precipitation, double precipitationCumulative, double evaporation, double evaporationCumulative,
                                      double surfacewaterInfiltration, double groundwaterRecharge, EvapoTranspirationStateStruct evapoTranspirationState,
                                      double meshNeighborsSurfacewaterFlowRate[MeshElement::meshNeighborsSize],
                                      double meshNeighborsSurfacewaterCumulativeFlow[MeshElement::meshNeighborsSize],
                                      double meshNeighborsGroundwaterFlowRate[MeshElement::meshNeighborsSize],
                                      double meshNeighborsGroundwaterCumulativeFlow[MeshElement::meshNeighborsSize],
                                      double channelNeighborsSurfacewaterFlowRate[MeshElement::channelNeighborsSize],
                                      double channelNeighborsSurfacewaterCumulativeFlow[MeshElement::channelNeighborsSize],
                                      double channelNeighborsGroundwaterFlowRate[MeshElement::channelNeighborsSize],
                                      double channelNeighborsGroundwaterCumulativeFlow[MeshElement::channelNeighborsSize])
                {
                  serial
                  {
                    handleMeshStateMessage(element, surfacewaterDepth, surfacewaterError, groundwaterHead, groundwaterError, precipitation,
                                           precipitationCumulative, evaporation, evaporationCumulative, surfacewaterInfiltration, groundwaterRecharge,
                                           evapoTranspirationState, meshNeighborsSurfacewaterFlowRate, meshNeighborsSurfacewaterCumulativeFlow,
                                           meshNeighborsGroundwaterFlowRate, meshNeighborsGroundwaterCumulativeFlow, channelNeighborsSurfacewaterFlowRate,
                                           channelNeighborsSurfacewaterCumulativeFlow, channelNeighborsGroundwaterFlowRate,
                                           channelNeighborsGroundwaterCumulativeFlow);
                  }
                }
                
                when channelStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double precipitation, double precipitationCumulative,
                                         double evaporation, double evaporationCumulative, EvapoTranspirationStateStruct evapoTranspirationState,
                                         double channelNeighborsSurfacewaterFlowRate[ChannelElement::channelNeighborsSize],
                                         double channelNeighborsSurfacewaterCumulativeFlow[ChannelElement::channelNeighborsSize],
                                         double meshNeighborsSurfacewaterFlowRate[ChannelElement::meshNeighborsSize],
                                         double meshNeighborsSurfacewaterCumulativeFlow[ChannelElement::meshNeighborsSize],
                                         double meshNeighborsGroundwaterFlowRate[ChannelElement::meshNeighborsSize],
                                         double meshNeighborsGroundwaterCumulativeFlow[ChannelElement::meshNeighborsSize])
                {
                  serial
                  {
                    handleChannelStateMessage(element, surfacewaterDepth, surfacewaterError, precipitation, precipitationCumulative, evaporation,
                                              evaporationCumulative, evapoTranspirationState, channelNeighborsSurfacewaterFlowRate,
                                              channelNeighborsSurfacewaterCumulativeFlow, meshNeighborsSurfacewaterFlowRate,
                                              meshNeighborsSurfacewaterCumulativeFlow, meshNeighborsGroundwaterFlowRate,
                                              meshNeighborsGroundwaterCumulativeFlow);
                  }
                }
              }
            }
            
            serial
            {
              contribute();
            }
            
            // Updating state must always be followed by writing that state into the output files.
            when writeFiles(size_t directorySize, const char directory[directorySize], bool writeGeometry, bool writeParameter, bool writeState)
            {
              serial
              {
                handleWriteFiles(directory, writeGeometry, writeParameter, writeState);
              }
            }
          } // End when updateState.
        } // End case within while (true).
      } // End while (true).
    }; // End entry void runForever().
    
    entry void initializeFromASCIIFiles(size_t directorySize, const char directory[directorySize], size_t fileBasenameSize,
                                        const char fileBasename[fileBasenameSize]);
    entry void initializeFromNetCDFFiles(size_t directorySize, const char directory[directorySize]);
    entry void getMeshVertexDataMessage(int requester, int element, int vertex, int node);
    entry void getChannelVertexDataMessage(int requester, int element, int vertex, int node);
    entry void meshVertexDataMessage(int element, int vertex, double x, double y, double zSurface);
    entry void channelVertexDataMessage(int element, int vertex, double x, double y, double zBank);
    entry void createFiles(size_t directorySize, const char directory[directorySize]);
    entry void writeFiles(size_t directorySize, const char directory[directorySize], bool writeGeometry, bool writeParameter, bool writeState);
    entry void readForcingData(size_t directorySize, const char directory[directorySize], CProxy_MeshElement meshProxy, CProxy_ChannelElement channelProxy,
                               double referenceDate, double currentTime);
    entry void updateState(double referenceDateNew, double currentTimeNew, double dtNew, size_t iterationNew);
    entry void meshStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double groundwaterHead, double groundwaterError,
                                double precipitation, double precipitationCumulative, double evaporation, double evaporationCumulative,
                                double surfacewaterInfiltration, double groundwaterRecharge, EvapoTranspirationStateStruct evapoTranspirationState,
                                double meshNeighborsSurfacewaterFlowRate[MeshElement::meshNeighborsSize],
                                double meshNeighborsSurfacewaterCumulativeFlow[MeshElement::meshNeighborsSize],
                                double meshNeighborsGroundwaterFlowRate[MeshElement::meshNeighborsSize],
                                double meshNeighborsGroundwaterCumulativeFlow[MeshElement::meshNeighborsSize],
                                double channelNeighborsSurfacewaterFlowRate[MeshElement::channelNeighborsSize],
                                double channelNeighborsSurfacewaterCumulativeFlow[MeshElement::channelNeighborsSize],
                                double channelNeighborsGroundwaterFlowRate[MeshElement::channelNeighborsSize],
                                double channelNeighborsGroundwaterCumulativeFlow[MeshElement::channelNeighborsSize]);
    entry void channelStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double precipitation, double precipitationCumulative,
                                   double evaporation, double evaporationCumulative, EvapoTranspirationStateStruct evapoTranspirationState,
                                   double channelNeighborsSurfacewaterFlowRate[ChannelElement::channelNeighborsSize],
                                   double channelNeighborsSurfacewaterCumulativeFlow[ChannelElement::channelNeighborsSize],
                                   double meshNeighborsSurfacewaterFlowRate[ChannelElement::meshNeighborsSize],
                                   double meshNeighborsSurfacewaterCumulativeFlow[ChannelElement::meshNeighborsSize],
                                   double meshNeighborsGroundwaterFlowRate[ChannelElement::meshNeighborsSize],
                                   double meshNeighborsGroundwaterCumulativeFlow[ChannelElement::meshNeighborsSize]);
  }; // End group FileManager.
}; // End module file_manager.
