module file_manager
{
  group FileManager
  {
    entry FileManager();
    
    entry void initialize()
    {
      case
      {
        when initializeFromASCIIFiles(size_t directorySize, const char directory[directorySize],
                                      size_t fileBasenameSize, const char fileBasename[fileBasenameSize])
        {
          serial
          {
            handleInitializeFromASCIIFiles(directorySize, directory, fileBasenameSize, fileBasename);
          }
        }
        
        when initializeFromNetCDFFiles(size_t directorySize, const char directory[directorySize])
        {
          serial
          {
            handleInitializeFromNetCDFFiles(directorySize, directory);
          }
        }
      }
    };
    
    entry void initializeFromASCIIFiles(size_t directorySize, const char directory[directorySize],
                                        size_t fileBasenameSize, const char fileBasename[fileBasenameSize]);
    entry void initializeFromNetCDFFiles(size_t directorySize, const char directory[directorySize]);
    entry void calculateDerivedValues();
    entry void getMeshVertexDataMessage(int requester, int element, int vertex, int node);
    
    entry void waitForVertexData()
    {
      while (!allVerticesUpdated())
      {
        when meshVertexDataMessage(int element, int vertex, double x, double y, double zSurface, double zBedrock)
        {
          serial
          {
            handleMeshVertexDataMessage(element, vertex, x, y, zSurface, zBedrock);
          }
        }
      }
      
      serial
      {
        delete[] meshVertexUpdated;
        
        finishCalculateDerivedValues();
      }
    };
    
    entry void meshVertexDataMessage(int element, int vertex, double x, double y, double zSurface, double zBedrock);
    entry void readForcingData(CProxy_MeshElement meshProxy, CProxy_ChannelElement channelProxy, double currentTime, size_t directorySize,
                               const char directory[directorySize]);
    entry void createFiles(size_t directorySize, const char directory[directorySize]);
    entry void resizeUnlimitedDimensions(size_t directorySize, const char directory[directorySize], bool writeGeometry, bool writeParameter, bool writeState);
    entry void writeFiles(size_t directorySize, const char directory[directorySize], bool writeGeometry, bool writeParameter, bool writeState);
    
    entry void updateState(double currentTimeNew, double dtNew, CMK_REFNUM_TYPE iterationNew)
    {
      serial
      {
        int ii; // Loop counter.
        
#if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
        if (!(0.0 < dtNew))
          {
            CkError("ERROR in FileManager::updateState: dtNew must be greater than zero.\n");
            CkExit();
          }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)

        currentTime = currentTimeNew;
        dt          = dtNew;
        iteration   = iterationNew;
        
        for (ii = 0; ii < localNumberOfMeshElements; ii++)
        {
          meshElementUpdated[ii] = false;
        }
        
        for (ii = 0; ii < localNumberOfChannelElements; ii++)
        {
          channelElementUpdated[ii] = false;
        }
      }
      
      while (!allElementsUpdated())
      {
        case
        {
          when meshStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double groundwaterHead, double groundwaterError, double precipitationCumulative, double evaporationCumulative, 
                                float canLiq, float canIce, float snEqv, double meshNeighborsSurfacewaterCumulativeFlow[MeshElement::meshNeighborsSize], 
                                double meshNeighborsGroundwaterCumulativeFlow[MeshElement::meshNeighborsSize] )
          {
            serial
            {
#if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
              if (!(localMeshElementStart <= element && element < localMeshElementStart + localNumberOfMeshElements))
                {
                  CkError("ERROR in FileManager::meshStateMessage, element %d: element data not owned by this local branch.\n", element);
                  CkExit();
                }
                
              if (!(0.0 <= surfacewaterDepth))
                {
                  CkError("ERROR in FileManager::meshStateMessage, element %d: surfacewaterDepth must be greater than or equal to zero.\n", element);
                  CkExit();
                }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)

              meshSurfacewaterDepth[element - localMeshElementStart]        = surfacewaterDepth;
              meshSurfacewaterError[element - localMeshElementStart]        = surfacewaterError;
              meshGroundwaterHead[element - localMeshElementStart]          = groundwaterHead;
              meshGroundwaterError[element - localMeshElementStart]         = groundwaterError;
              meshPrecipitationCumulative[element - localMeshElementStart]  = precipitationCumulative;
              meshEvaporationCumulative[element - localMeshElementStart]    = evaporationCumulative;
              meshCanopyLiquid[element - localMeshElementStart]             = canLiq;
              meshCanopyIce[element - localMeshElementStart]                = canIce;
              meshSnowWaterEquivalent[element - localMeshElementStart]      = snEqv;
              
              for (int nn = 0; nn < MeshElement::meshNeighborsSize; nn++)
                 {
                   meshElementNeighborsSurfacewaterCumulativeFlow[element - localMeshElementStart][nn] = meshNeighborsSurfacewaterCumulativeFlow[nn];
                   meshElementNeighborsGroundwaterCumulativeFlow[element - localMeshElementStart][nn]  = meshNeighborsGroundwaterCumulativeFlow[nn];
                 }
                        
              meshElementUpdated[element - localMeshElementStart]           = true;
            }
          }
          
          when channelStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double evaporationCumulative, double channelNeighborsSurfacewaterCumulativeFlow[ChannelElement::channelNeighborsSize] )
          {
            serial
            {
#if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
              if (!(localChannelElementStart <= element && element < localChannelElementStart + localNumberOfChannelElements))
                {
                  CkError("ERROR in FileManager::channelStateMessage, element %d: element data not owned by this local branch.\n", element);
                  CkExit();
                }
                
              if (!(0.0 <= surfacewaterDepth))
                {
                  CkError("ERROR in FileManager::channelStateMessage, element %d: surfacewaterDepth must be greater than or equal to zero.\n", element);
                  CkExit();
                }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)

              channelSurfacewaterDepth[element - localChannelElementStart]      = surfacewaterDepth;
              channelSurfacewaterError[element - localChannelElementStart]      = surfacewaterError;
              channelEvaporationCumulative [element - localChannelElementStart] = evaporationCumulative;
              
              for (int nn = 0; nn < ChannelElement::channelNeighborsSize; nn++)
                 {
                   //channelNeighborsSurfacewaterCumulativeFlow[element - localMeshElementStart][nn] = channelNeighborsSurfacewaterCumulativeFlow[nn];
                 }
                 
              channelElementUpdated[element - localChannelElementStart]         = true;
            }
          }
        } // End case within while (!allElementsUpdated()).
      } // End while (!allElementsUpdated()).
      
      serial
      {
        contribute();
      }
    }; // End updateState.
    
    entry void meshStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double groundwaterHead, double groundwaterError, double precipitationCumulative, double evaporationCumulative, 
                                float canLiq, float canIce, float snEqv, double meshNeighborsSurfacewaterCumulativeFlow[MeshElement::meshNeighborsSize], 
                                double meshNeighborsGroundwaterCumulativeFlow[MeshElement::meshNeighborsSize]);
    entry void channelStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double evaporationCumulative, double channelNeighborsSurfacewaterCumulativeFlow[ChannelElement::channelNeighborsSize]);
  }; // End group FileManager.
}; // End module file_manager.
