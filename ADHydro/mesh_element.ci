module mesh_element
{
  extern module file_manager;
  
  array [1D] MeshElement
  {
    entry MeshElement(CProxy_FileManager fileManagerProxyInit);
    
    // Dummy function for structured dagger infinite loop.
    entry void runForever()
    {
      serial
      {
        initialize();
      }
      
      while (true)
      {
        case
        {
          when doTimestep(int iterationThisTimestep, double dtThisTimestep)
          {
            serial
            {
              handleDoTimestep(iterationThisTimestep, dtThisTimestep);
            }

            while (!timestepDone)
            {
              case
              {
                when calculateBoundaryConditionFlowRate[iteration](int iterationThisMessage)
                {
                  serial
                  {
                    handleCalculateBoundaryConditionFlowRate();
                  }
                }

                when stateMessage[iteration](int iterationThisMessage, int edge, double neighborSurfacewaterDepth, double neighborGroundwaterHead)
                {
                  serial
                  {
                    handleStateMessage(edge, neighborSurfacewaterDepth, neighborGroundwaterHead);
                  }
                }

                when flowRateMessage[iteration](int iterationThisMessage, int edge, double edgeSurfacewaterFlowRate, double edgeGroundwaterFlowRate)
                {
                  serial
                  {
                    handleFlowRateMessage(edge, edgeSurfacewaterFlowRate, edgeGroundwaterFlowRate);
                  }
                }

                when surfacewaterFlowRateLimitedMessage[iteration](int iterationThisMessage, int edge, double edgeSurfacewaterFlowRate)
                {
                  serial
                  {
                    handleSurfacewaterFlowRateLimitedMessage(edge, edgeSurfacewaterFlowRate);
                  }
                }
              }
            }
          }
          
          // Receive stale messages that were not received in previous timesteps because they were not needed.
          when calculateBoundaryConditionFlowRate(int iterationThisMessage)
          {
            serial
            {
              // At this point, iteration is the value for the previous timestep that was completed.  
              if (iteration < iterationThisMessage)
              {
                // If a message for the next timestep arrives requeue it.
                thisProxy[thisIndex].calculateBoundaryConditionFlowRate(iterationThisMessage);
              }
              else
              {
                // If a message for an earlier timestep arrives discard it.
                // Disabling this message because it is too verbose.  Any element with no boundary edges discards one of these messages every timestep.
                //CkPrintf("NOTE: Element %d, completed iteration %d: "
                //         "Discarding unneeded stale calculateBoundaryConditionFlowRate message for iteration %d.\n", iterationThisMessage);
              }
            }
          }

          // Receive stale messages that were not received in previous timesteps because they were not needed.
          when stateMessage(int iterationThisMessage, int edge, double neighborSurfacewaterDepth, double neighborGroundwaterHead)
          {
            serial
            {
              // At this point, iteration is the value for the previous timestep that was completed.  
              if (iteration < iterationThisMessage)
              {
                // If a message for the next timestep arrives requeue it.
                thisProxy[thisIndex].stateMessage(iterationThisMessage, edge, neighborSurfacewaterDepth, neighborGroundwaterHead);
              }
              else
              {
                // If a message for an earlier timestep arrives discard it.
                CkPrintf("NOTE: Element %d, completed iteration %d: Discarding unneeded stale state message for iteration %d.\n", iterationThisMessage);
              }
            }
          }

          // Receive stale messages that were not received in previous timesteps because they were not needed.
          when flowRateMessage(int iterationThisMessage, int edge, double edgeSurfacewaterFlowRate, double edgeGroundwaterFlowRate)
          {
            serial
            {
              // At this point, iteration is the value for the previous timestep that was completed.  
              if (iteration < iterationThisMessage)
              {
                // If a message for the next timestep arrives requeue it.
                thisProxy[thisIndex].flowRateMessage(iterationThisMessage, edge, edgeSurfacewaterFlowRate, edgeGroundwaterFlowRate);
              }
              else
              {
                // If a message for an earlier timestep arrives discard it.
                CkPrintf("NOTE: Element %d, completed iteration %d: Discarding unneeded stale flow rate message for iteration %d.\n", iterationThisMessage);
              }
            }
          }

          when output()
          {
            serial
            {
              handleOutput();
            }
          }
        
          when checkInvariant()
          {
            serial
            {
              handleCheckInvariant();
            }
            
            while (!(neighborInvariantChecked[0] && neighborInvariantChecked[1] && neighborInvariantChecked[2]))
            {
              when checkInvariantNeighbor(int neighborIndex, InteractionEnum neighborsNeighborInteraction, int neighborEdge,
                                          int neighborsNeighborReciprocalEdge, double neighborVertexX1, double neighborVertexX2, double neighborVertexY1,
                                          double neighborVertexY2, double neighborVertexZSurface1, double neighborVertexZSurface2,
                                          double neighborVertexZBedrock1, double neighborVertexZBedrock2, double neighborElementX,
                                          double neighborElementY, double neighborElementZSurface, double neighborElementZBedrock,
                                          double neighborElementConductivity, double neighborElementManningsN, double neighborSurfacewaterFlowRate,
                                          double neighborSurfacewaterCumulativeFlow, double neighborGroundwaterFlowRate,
                                          double neighborGroundwaterCumulativeFlow, int neighborIteration, double neighborDt)
              {
                serial
                {
                  handleCheckInvariantNeighbor(neighborIndex, neighborsNeighborInteraction, neighborEdge, neighborsNeighborReciprocalEdge, neighborVertexX1,
                                               neighborVertexX2, neighborVertexY1, neighborVertexY2, neighborVertexZSurface1, neighborVertexZSurface2,
                                               neighborVertexZBedrock1, neighborVertexZBedrock2, neighborElementX, neighborElementY, neighborElementZSurface,
                                               neighborElementZBedrock, neighborElementConductivity, neighborElementManningsN, neighborSurfacewaterFlowRate,
                                               neighborSurfacewaterCumulativeFlow, neighborGroundwaterFlowRate, neighborGroundwaterCumulativeFlow,
                                               neighborIteration, neighborDt);
                }
              }
            }
            
            serial
            {
              contribute();
            }
          }
        }
      }
    };

    entry void doTimestep(int iterationThisTimestep, double dtThisTimestep);
    entry void calculateBoundaryConditionFlowRate(int iterationThisMessage);
    entry void stateMessage(int iterationThisMessage, int edge, double neighborSurfacewaterDepth, double neighborGroundwaterHead);
    entry void flowRateMessage(int iterationThisMessage, int edge, double edgeSurfacewaterFlowRate, double edgeGroundwaterFlowRate);
    entry void surfacewaterFlowRateLimitedMessage(int iterationThisMessage, int edge, double edgeSurfacewaterFlowRate);
    entry void output();
    entry void checkInvariant();
    entry void checkInvariantNeighbor(int neighborIndex, InteractionEnum neighborsNeighborInteraction, int neighborEdge,
                                      int neighborsNeighborReciprocalEdge, double neighborVertexX1, double neighborVertexX2, double neighborVertexY1,
                                      double neighborVertexY2, double neighborVertexZSurface1, double neighborVertexZSurface2,
                                      double neighborVertexZBedrock1, double neighborVertexZBedrock2, double neighborElementX,
                                      double neighborElementY, double neighborElementZSurface, double neighborElementZBedrock,
                                      double neighborElementConductivity, double neighborElementManningsN, double neighborSurfacewaterFlowRate,
                                      double neighborSurfacewaterCumulativeFlow, double neighborGroundwaterFlowRate,
                                      double neighborGroundwaterCumulativeFlow, int neighborIteration, double neighborDt);
  };
};
