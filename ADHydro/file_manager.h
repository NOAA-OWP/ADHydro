#ifndef __FILE_MANAGER_H__
#define __FILE_MANAGER_H__

// file_manager.decl.h needs CProxy_MeshElement from mesh_element.decl.h and CProxy_ChannelElement from channel_element.decl.h.
// mesh_element.decl.h needs CProxy_FileManager from file_manager.decl.h and CProxy_ChannelElement from channel_element.decl.h.
// channel_element.decl.h needs CProxy_FileManager from file_manager.decl.h and CProxy_MeshElement from mesh_element.decl.h.
// These forward declarations break the circularity.
class CProxy_MeshElement;
class CProxy_ChannelElement;

#include "evapo_transpiration.h"

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wsign-compare"
#include "file_manager.decl.h"
#pragma GCC diagnostic warning "-Wsign-compare"

#include "mesh_element.h"
#include "channel_element.h"
#include <netcdf.h>

typedef float  FloatArraySnowLayers[EVAPO_TRANSPIRATION_NUMBER_OF_SNOW_LAYERS]; // Fixed size array of floats.  Size is number of E-T snow layers.
typedef float  FloatArrayAllLayers[EVAPO_TRANSPIRATION_NUMBER_OF_ALL_LAYERS];   // Fixed size array of floats.  Size is number of E-T snow and soil layers.
typedef int    IntArrayMMN[MeshElement::meshNeighborsSize];                     // Fixed size array of ints.    Size is mesh    mesh neighbors.
typedef bool   BoolArrayMMN[MeshElement::meshNeighborsSize];                    // Fixed size array of bools.   Size is mesh    mesh neighbors.
typedef double DoubleArrayMMN[MeshElement::meshNeighborsSize];                  // Fixed size array of doubles. Size is mesh    mesh neighbors.
typedef int    IntArrayMCN[MeshElement::channelNeighborsSize];                  // Fixed size array of ints.    Size is mesh    channel neighbors.
typedef double DoubleArrayMCN[MeshElement::channelNeighborsSize];               // Fixed size array of doubles. Size is mesh    channel neighbors.
typedef int    IntArrayXDMF[ChannelElement::channelVerticesSize + 2];           // Fixed size array of ints.    Size is channel vertices + 2.
                                                                                // This is used only for channelElementVertices.
                                                                                // See the comment of that variable for explanation.
typedef double DoubleArrayCV[ChannelElement::channelVerticesSize];              // Fixed size array of doubles. Size is channel vertices.
typedef bool   BoolArrayCV[ChannelElement::channelVerticesSize];                // Fixed size array of bools.   Size is channel vertices.
typedef int    IntArrayCCN[ChannelElement::channelNeighborsSize];               // Fixed size array of ints.    Size is channel channel neighbors.
typedef double DoubleArrayCCN[ChannelElement::channelNeighborsSize];            // Fixed size array of doubles. Size is channel channel neighbors.
typedef int    IntArrayCMN[ChannelElement::meshNeighborsSize];                  // Fixed size array of ints.    Size is channel mesh neighbors.
typedef double DoubleArrayCMN[ChannelElement::meshNeighborsSize];               // Fixed size array of doubles. Size is channel mesh neighbors.

// The group of file managers acts as an in-memory cache for values that are
// read from and written to NetCDF files.  Reading and writing individual
// values from NetCDF files is too slow.  We need to read and write large
// blocks from the arrays in the NetCDF files.  However, individual values are
// needed by mesh and channel elements.  The file manager group does the block
// reads and writes and makes the values available to the elements.
//
// At initialization, each file manager takes ownership of a block of each
// array containing the data for the elements that get assigned to its
// processor by the default Charm++ block mapping of array elements to
// processors.  This way, elements can initialize themselves without any
// message passing by getting a pointer to the file manager local branch and
// accessing its public member variables.
//
// After initialization, array elements might migrate away from the file
// manager local branch that owns their data.  We do not transfer ownership of
// the data between file manager local branches.  Instead, message passing is
// used to update data after initialization.
class FileManager : public CBase_FileManager
{
  FileManager_SDAG_CODE
  
public:

  // Calculate which file manager owns a given item.  The first
  // (globalNumberOfItems % CkNumPes()) file managers each have
  // (globalNumberOfItems / CkNumPes() + 1) items.  The remaining file managers
  // each have (globalNumberOfItems / CkNumPes()) items.
  //
  // Returns: the index of the file manager that owns item.
  //
  // Parameters:
  //
  // item                - The index of this item.
  // globalNumberOfItems - The total number of this kind of item.
  static int home(int item, int globalNumberOfItems);
  
  // Constructor.  Initializes the file manager to hold no data and starts the
  // runForever function in the SDAG code.
  FileManager();
  
  // Destructor.  Dynamically allocated arrays need to be deleted.
  ~FileManager();
  
  // Send requested vertex coordinates.
  //
  // Parameters:
  //
  // requester - File manager requesting vertex coordinates.
  // element   - Element that has vertex.
  // vertex    - Vertex requesting coordinates for.
  // node      - Node index of vertex.
  void getMeshVertexDataMessage(int requester, int element, int vertex, int node);
  
  // Send requested vertex coordinates.
  //
  // Parameters:
  //
  // requester - File manager requesting vertex coordinates.
  // element   - Element that has vertex.
  // vertex    - Vertex requesting coordinates for.
  // node      - Node index of vertex.
  void getChannelVertexDataMessage(int requester, int element, int vertex, int node);
  
  int globalNumberOfMeshNodes;       // Number of mesh nodes across all file managers.
  int localMeshNodeStart;            // Index of first mesh node owned by this local branch.
  int localNumberOfMeshNodes;        // Number of mesh nodes owned by this local branch.
  int globalNumberOfMeshElements;    // Number of mesh elements across all file managers.
  int localMeshElementStart;         // Index of first mesh element owned by this local branch.
  int localNumberOfMeshElements;     // Number of mesh elements owned by this local branch.
  int globalNumberOfChannelNodes;    // Number of channel nodes across all file managers.
  int localChannelNodeStart;         // Index of first channel node owned by this local branch.
  int localNumberOfChannelNodes;     // Number of channel nodes owned by this local branch.
  int globalNumberOfChannelElements; // Number of channel elements across all file managers.
  int localChannelElementStart;      // Index of first channel element owned by this local branch.
  int localNumberOfChannelElements;  // Number of channel elements owned by this local branch.
  
  // The following are pointers to dynamically allocated arrays containing the
  // data owned by this local branch.  The pointers can be NULL indicating the
  // data is not available.  Elements must check that the data they need to
  // initialize themselves is available.
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* meshNodeX;
  double* meshNodeY;
  double* meshNodeZSurface;
  
  // This array stores the node indices of the vertices of each element.
  IntArrayMMN* meshElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Even this information is not used directly by the elements.  Instead, each
  // local branch calculates element values dervied from the vertex coordinates.
  DoubleArrayMMN* meshVertexX;
  DoubleArrayMMN* meshVertexY;
  DoubleArrayMMN* meshVertexZSurface;
  
  // These arrays store the values used directly by the elements.
  double*               meshElementX;
  double*               meshElementY;
  double*               meshElementZSurface;
  double*               meshElementSoilDepth;
  double*               meshElementZBedrock;
  double*               meshElementArea;
  double*               meshElementSlopeX;
  double*               meshElementSlopeY;
  int*                  meshCatchment;
  int*                  meshVegetationType;
  int*                  meshSoilType;
  double*               meshConductivity;
  double*               meshPorosity;
  double*               meshManningsN;
  double*               meshSurfacewaterDepth;
  double*               meshSurfacewaterError;
  double*               meshGroundwaterHead;
  double*               meshGroundwaterError;
  double*               meshPrecipitation;
  double*               meshPrecipitationCumulative;
  double*               meshEvaporation;
  double*               meshEvaporationCumulative;
  double*               meshSurfacewaterInfiltration;
  double*               meshGroundwaterRecharge;
  FloatArraySnowLayers* meshFIceOld;
  float*                meshAlbOld;
  float*                meshSnEqvO;
  FloatArrayAllLayers*  meshStc;
  float*                meshTah;
  float*                meshEah;
  float*                meshFWet;
  float*                meshCanLiq;
  float*                meshCanIce;
  float*                meshTv;
  float*                meshTg;
  int*                  meshISnow;
  FloatArrayAllLayers*  meshZSnso;
  float*                meshSnowH;
  float*                meshSnEqv;
  FloatArraySnowLayers* meshSnIce;
  FloatArraySnowLayers* meshSnLiq;
  float*                meshLfMass;
  float*                meshRtMass;
  float*                meshStMass;
  float*                meshWood;
  float*                meshStblCp;
  float*                meshFastCp;
  float*                meshLai;
  float*                meshSai;
  float*                meshCm;
  float*                meshCh;
  float*                meshTauss;
  float*                meshDeepRech;
  float*                meshRech;
  IntArrayMMN*          meshMeshNeighbors;
  BoolArrayMMN*         meshMeshNeighborsChannelEdge;
  DoubleArrayMMN*       meshMeshNeighborsEdgeLength;
  DoubleArrayMMN*       meshMeshNeighborsEdgeNormalX;
  DoubleArrayMMN*       meshMeshNeighborsEdgeNormalY;
  DoubleArrayMMN*       meshMeshNeighborsSurfacewaterFlowRate;
  DoubleArrayMMN*       meshMeshNeighborsSurfacewaterCumulativeFlow;
  DoubleArrayMMN*       meshMeshNeighborsGroundwaterFlowRate;
  DoubleArrayMMN*       meshMeshNeighborsGroundwaterCumulativeFlow;
  IntArrayMCN*          meshChannelNeighbors;
  DoubleArrayMCN*       meshChannelNeighborsEdgeLength;
  DoubleArrayMCN*       meshChannelNeighborsSurfacewaterFlowRate;
  DoubleArrayMCN*       meshChannelNeighborsSurfacewaterCumulativeFlow;
  DoubleArrayMCN*       meshChannelNeighborsGroundwaterFlowRate;
  DoubleArrayMCN*       meshChannelNeighborsGroundwaterCumulativeFlow;
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* channelNodeX;
  double* channelNodeY;
  double* channelNodeZBank;
  
  // This array stores the node indices of the vertices of each element, but
  // with some special properties required for display as an XDMF file.
  // We want to display streams as polylines and waterbodies as polygons.
  // In XDMF this requires a mixed topology.  In a mixed topology, each element
  // must store its shape type, either 2 for polyline or 3 for polygon, and
  // number of vertices followed by the node indices of the vertices.  In order
  // for the mixed topology to work with the rectangular arrays of NetCDF files
  // all elements must have the same number of vertices.  Therefore,
  // channelElementVertices[n][0] is the shape type, always 2 or 3,
  // channelElementVertices[n][1] is the number of vertices, always
  // ChannelElement::channelVerticesSize, and the remaining values are the node
  // indices of ther vertices with channelElementVertices[n][2] holding vertex
  // 0, channelElementVertices[n][3] holding vertex 1, etc.  If a shape has
  // fewer vertices than ChannelElement::channelVerticesSize then the last
  // vertex is repeated as necessary.
  IntArrayXDMF* channelElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Even this information is not used directly by the elements.  Instead, each
  // local branch calculates element values dervied from the vertex coordinates.
  DoubleArrayCV* channelVertexX;
  DoubleArrayCV* channelVertexY;
  DoubleArrayCV* channelVertexZBank;
  
  // These arrays store the values used directly by the elements.
  double*               channelElementX;
  double*               channelElementY;
  double*               channelElementZBank;
  double*               channelElementBankFullDepth;
  double*               channelElementZBed;
  double*               channelElementLength;
  ChannelTypeEnum*      channelChannelType;
  int*                  channelPermanentCode;
  double*               channelBaseWidth;
  double*               channelSideSlope;
  double*               channelBedConductivity;
  double*               channelBedThickness;
  double*               channelManningsN;
  double*               channelSurfacewaterDepth;
  double*               channelSurfacewaterError;
  double*               channelPrecipitation;
  double*               channelPrecipitationCumulative;
  double*               channelEvaporation;
  double*               channelEvaporationCumulative;
  FloatArraySnowLayers* channelFIceOld;
  float*                channelAlbOld;
  float*                channelSnEqvO;
  FloatArrayAllLayers*  channelStc;
  float*                channelTah;
  float*                channelEah;
  float*                channelFWet;
  float*                channelCanLiq;
  float*                channelCanIce;
  float*                channelTv;
  float*                channelTg;
  int*                  channelISnow;
  FloatArrayAllLayers*  channelZSnso;
  float*                channelSnowH;
  float*                channelSnEqv;
  FloatArraySnowLayers* channelSnIce;
  FloatArraySnowLayers* channelSnLiq;
  float*                channelLfMass;
  float*                channelRtMass;
  float*                channelStMass;
  float*                channelWood;
  float*                channelStblCp;
  float*                channelFastCp;
  float*                channelLai;
  float*                channelSai;
  float*                channelCm;
  float*                channelCh;
  float*                channelTauss;
  float*                channelDeepRech;
  float*                channelRech;
  IntArrayCCN*          channelChannelNeighbors;
  DoubleArrayCCN*       channelChannelNeighborsSurfacewaterFlowRate;
  DoubleArrayCCN*       channelChannelNeighborsSurfacewaterCumulativeFlow;
  IntArrayCMN*          channelMeshNeighbors;
  DoubleArrayCMN*       channelMeshNeighborsEdgeLength;
  DoubleArrayCMN*       channelMeshNeighborsSurfacewaterFlowRate;
  DoubleArrayCMN*       channelMeshNeighborsSurfacewaterCumulativeFlow;
  DoubleArrayCMN*       channelMeshNeighborsGroundwaterFlowRate;
  DoubleArrayCMN*       channelMeshNeighborsGroundwaterCumulativeFlow;
  
  // Time information.  This is only kept up to date when inputting or outputting.
  double referenceDate; // The Julian date when currentTime is zero.  The current date and time of the simulation is the Julian date equal to
                        // referenceDate + currentTime / (24.0 * 3600.0).
  double currentTime;   // Current simulation time in seconds since referenceDate.
  double dt;            // Next simulation timestep duration in seconds.
  size_t iteration;     // Simulation iteration number.
  
  // Forcing data information.
  bool   forcingDataInitialized; // True if forcing data has been read in and sent to mesh and channel elements at least once.
  double forcingDataDate;        // The Julian date of the last forcing data read in and sent to mesh and channel elements.
  double nextForcingDataDate;    // The next Julian date at which new forcing data is available.
  
private:
  
  // Calculate which items this file manager owns.  The first
  // (globalNumberOfItems % CkNumPes()) file managers each have
  // (globalNumberOfItems / CkNumPes() + 1) items.  The remaining file managers
  // each have (globalNumberOfItems / CkNumPes()) items.
  //
  // Parameters:
  //
  // localItemStart      - Scalar passed by reference will be filled in with
  //                       the local start index.
  // localNumberOfItems  - Scalar passed by reference will be filled in with
  //                       the local number of items.
  // globalNumberOfItems - The total number of this kind of item.
  static void localStartAndNumber(int* localItemStart, int* localNumberOfItems, int globalNumberOfItems);
  
  // Open or create a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // directory - The directory in which to open or create the file.
  // filename  - The file to open or create.
  // create    - Whether to create the file.  If true, it is an error if the
  //             file already exists.  If false, it is an error if the file
  //             does not already exist.
  // write     - Whether to open the file for write.  If false, the file is
  //             opened read-only.  If create is true, write is ignored and the
  //             file is always created open for write.
  // fileID    - Scalar passed by reference will be filled in with the ID of
  //             the open file.
  bool openNetCDFFile(const char* directory, const char* filename, bool create, bool write, int* fileID);
  
  // Create a dimension in a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // fileID        - The file ID of the NetCDF file.
  // dimensionName - The name of the dimension to create.
  // dimensionSize - The size of the dimension to create.
  // dimensionID   - Scalar passed by reference will be filled in with the ID
  //                 of the created dimension.
  bool createNetCDFDimension(int fileID, const char* dimensionName, size_t dimensionSize, int* dimensionID);
  
  // Get the size of a dimension in a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // fileID        - The file ID of the NetCDF file.
  // dimensionName - The name of the dimension to get the size of.
  // dimensionSize - Scalar passed by reference will be filled in with the size
  //                 of the dimension.
  bool readNetCDFDimensionSize(int fileID, const char* dimensionName, size_t* dimensionSize);
  
  // Create a variable in a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // fileID             - The file ID of the NetCDF file.
  // variableName       - The name of the variable to create.
  // dataType           - The type of the variable to create.
  // numberOfDimensions - The number of dimensions of the variable to create.
  // dimensionID0       - The ID of the first dimension of the variable.
  // dimensionID1       - The ID of the second dimension of the variable.
  //                      Ignored if numberOfDimensions is less than two.
  // dimensionID2       - The ID of the third dimension of the variable.
  //                      Ignored if numberOfDimensions is less than three.
  bool createNetCDFVariable(int fileID, const char* variableName, nc_type dataType, int numberOfDimensions, int dimensionID0, int dimensionID1,
                            int dimensionID2);
  
  // Read a variable from a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // fileID                - The file ID of the NetCDF file.
  // variableName          - The name of the variable to read.
  // instance              - The index of the first dimension to read.
  //                         The count of the first dimension is always one.
  //                         This reads one particular instance in time.
  // nodeElementStart      - The index of the second dimension to read.  This
  //                         is ignored if the variable has less than two
  //                         dimensions.
  // numberOfNodesElements - The count of the second dimension to read.  If the
  //                         variable has less than two dimensions this must be
  //                         one. nodeElementStart and numberOfNodesElements
  //                         combine to specify a subset of the nodes or
  //                         elements stored in the variable.
  // fileDimension         - The count of the third dimension to read.  The
  //                         index of the third dimension is always zero.  If
  //                         the variable has less than three dimensions this
  //                         must be one.
  // memoryDimension       - The size of the third dimension in memory.  This
  //                         function can read an array whose third dimension
  //                         in the file is smaller than the desired third
  //                         dimension in memory.  In that case, what gets
  //                         filled in to the extra cells depends on
  //                         repeatLastValue and defaultValue.  It is an error
  //                         if memoryDimension is less than fileDimension.  If
  //                         the variable has less than three dimensions this
  //                         must be one.
  // repeatLastValue       - If there are extra cells to be filled in because
  //                         memoryDimension is greater than fileDimension then
  //                         if repeatLastValue is true the last value in each
  //                         row of the third dimension in the file is repeated
  //                         in the extra cells.  If repeatLastValue is false,
  //                         defaultValue is used instead.
  // defaultValue          - If there are extra cells to be filled in because
  //                         memoryDimension is greater than fileDimension then
  //                         if repeatLastValue is false the extra cells are
  //                         filled in with defaultValue.  If repeatLastValue
  //                         is true defaultValue is ignored.
  // mandatory             - Whether the existence of the variable is
  //                         mandatory.  If true, it is an error if the
  //                         variable does not exist.  If false, this function
  //                         does nothing if the variable does not exist.
  // variable              - A pointer passed by reference.  The pointer (that
  //                         is, *variable) may point to an array of size 1 *
  //                         numberOfNodesElements * fileDimension, which is
  //                         the size of the array that will be read, or it can
  //                         be NULL.  If it is NULL it will be set to point to
  //                         a newly allocated array.  This array, whether
  //                         passed in or newly allocated is filled in with the
  //                         values read from the NetCDF file.  Then, if
  //                         memoryDimension is greater than fileDimension it
  //                         is reallocated to the larger size.  NOTE: even if
  //                         you pass in an array, it will be deleted and
  //                         *variable will be set to point to a newly
  //                         allocated array if memoryDimension is greater than
  //                         fileDimension, but this will only happen if
  //                         memoryDimension is greater than fileDimension.
  //                         In any case, *variable will wind up pointing to an
  //                         array of size 1 * numberOfNodesElements *
  //                         memoryDimension.
  template <typename T> bool readNetCDFVariable(int fileID, const char* variableName, size_t instance, size_t nodeElementStart,
                                                size_t numberOfNodesElements, size_t fileDimension, size_t memoryDimension, bool repeatLastValue,
                                                T defaultValue, bool mandatory, T** variable);
  
  // Write a variable to a NetCDF file.
  //
  // Returns: true if there is an error, false otherwise.
  //
  // Parameters:
  //
  // fileID                - The file ID of the NetCDF file.
  // variableName          - The name of the variable to write.
  // instance              - The index of the first dimension to write.
  //                         The count of the first dimension is always one.
  //                         This writes one particular instance in time.
  // nodeElementStart      - The index of the second dimension to write.
  // numberOfNodesElements - The count of the second dimension to write.
  //                         nodeElementStart and numberOfNodesElements combine
  //                         to specify a subset of the nodes or elements
  //                         stored in the variable.  They are ignored if the
  //                         variable has less than two dimensions.
  // memoryDimension       - The count of the third dimension to write.  This
  //                         is ignored if the variable has less than three
  //                         dimensions.
  // variable              - An array of size 1 * numberOfNodesElements *
  //                         memoryDimension which will be written into the
  //                         variable in the file.
  bool writeNetCDFVariable(int fileID, const char* variableName, size_t instance, size_t nodeElementStart, size_t numberOfNodesElements,
                           size_t memoryDimension, void* variable);
  
  // Initialize the file manager from NetCDF files.
  //
  // Parameters:
  //
  // directory - The directory from which to read the files.
  void handleInitializeFromNetCDFFiles(const char* directory);
  
  // Check if vertex variables need to be updated from node variables and if so
  // send out get vertex data messages.
  void updateVertices();
  
  // Returns: true if all vertex information is updated, false otherwise.
  bool allVerticesUpdated();
  
  // Receive requested vertex coordinates.
  //
  // Parameters:
  //
  // element  - Element that has vertex.
  // vertex   - Vertex that coordinates are for.
  // x        - X coordinate of vertex.
  // y        - Y coordinate of vertex.
  // zSurface - Surface Z coordinate of vertex.
  void handleMeshVertexDataMessage(int element, int vertex, double x, double y, double zSurface);
  
  // Receive requested vertex coordinates.
  //
  // Parameters:
  //
  // element - Element that has vertex.
  // vertex  - Vertex that coordinates are for.
  // x       - X coordinate of vertex.
  // y       - Y coordinate of vertex.
  // zBank   - Bank Z coordinate of vertex.
  void handleChannelVertexDataMessage(int element, int vertex, double x, double y, double zBank);
  
  // If a variable is not available the file managers attempt to derive it from
  // other variables, for example element center coordinates from element
  // vertex coordinates.  If a variable is not available and cannot be derived
  // its array is unallocated and left as NULL.  When done the file managers
  // contribute to an empty reduction.
  void calculateDerivedValues();
  
  // Create NetCDF files for output including creating dimensions and variables
  // within the files.  When done the file managers contribute to an empty
  // reduction.
  //
  // Parameters:
  //
  // directory - The directory in which to create the files.
  void handleCreateFiles(const char* directory);
  
  // Write data to NetCDF files.  Files must already be created.  When done the
  // file managers contribute to an empty reduction.
  //
  // Parameters:
  //
  // directory      - The directory in which to write the files.
  // writeGeometry  - Whether to write a new instance into the geometry file.
  //                  If false, the last exsisting instance is used as the
  //                  instance to write into the state file and it is an error
  //                  if no instance exists.
  // writeParameter - Whether to write a new instance into the parameter file.
  //                  If false, the last exsisting instance is used as the
  //                  instance to write into the state file and it is an error
  //                  if no instance exists.
  // writeState     - Whether to write a new instance into the state file.
  void handleWriteFiles(const char* directory, bool writeGeometry, bool writeParameter, bool writeState);
  
  // Read forcing data from file and send to mesh and channel elements.  Each
  // file manager reads the data for the elements it owns and sends it on to
  // those elements.  This function does not contribute to a reduction, but
  // when mesh and channel elements receive forcing data they contribute to an
  // empty reduction.
  //
  // Parameters:
  //
  // directory        - The directory from which to read the files.
  // meshProxy        - The mesh elements to send the forcing data to.
  // channelProxy     - The channel elements to send the forcing data to.
  // referenceDateNew - The updated Julian date when currentTimeNew is zero.
  // currentTimeNew   - The updated time step in seconds.
  void handleReadForcingData(const char* directory, CProxy_MeshElement meshProxy, CProxy_ChannelElement channelProxy, double referenceDateNew,
                             double currentTimeNew);

  // Get ready to receive state information from mesh and channel elements.
  // This function does not contribute to a reduction, but after receiving
  // state messages from all mesh and channel elements the SDAG code
  // contributes to an empty reduction.
  //
  // Parameters:
  //
  // referenceDateNew - The updated Julian date when currentTimeNew is zero.
  // currentTimeNew   - The updated time step in seconds.
  // dtNew            - The updated simulation timestep duration in seconds.
  // iterationNew     - The updated simulation iteration number.
  void handleUpdateState(double referenceDateNew, double currentTimeNew, double dtNew, size_t iterationNew);
  
  // Returns: true if all element information is updated, false otherwise.
  bool allElementsUpdated();

  // Receive a state message from a mesh element and update the values for that
  // element in the file manager's variables.
  //
  // Parameters:
  //
  // element                                    - The element that is reporting
  //                                              its state.
  // surfacewaterDepth                          - mesh element state.
  // surfacewaterError                          - mesh element state.
  // groundwaterHead                            - mesh element state.
  // groundwaterError                           - mesh element state.
  // precipitation                              - mesh element state.
  // precipitationCumulative                    - mesh element state.
  // evaporation                                - mesh element state.
  // evaporationCumulative                      - mesh element state.
  // surfacewaterInfiltration                   - mesh element state.
  // groundwaterRecharge                        - mesh element state.
  // evapoTranspirationState                    - mesh element state.
  // meshNeighborsSurfacewaterFlowRate          - mesh element state.
  // meshNeighborsSurfacewaterCumulativeFlow    - mesh element state.
  // meshNeighborsGroundwaterFlowRate           - mesh element state.
  // meshNeighborsGroundwaterCumulativeFlow     - mesh element state.
  // channelNeighborsSurfacewaterFlowRate       - mesh element state.
  // channelNeighborsSurfacewaterCumulativeFlow - mesh element state.
  // channelNeighborsGroundwaterFlowRate        - mesh element state.
  // channelNeighborsGroundwaterCumulativeFlow  - mesh element state.
  void handleMeshStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double groundwaterHead, double groundwaterError,
                              double precipitation, double precipitationCumulative, double evaporation, double evaporationCumulative,
                              double surfacewaterInfiltration, double groundwaterRecharge, EvapoTranspirationStateStruct evapoTranspirationState,
                              double* meshNeighborsSurfacewaterFlowRate, double* meshNeighborsSurfacewaterCumulativeFlow,
                              double* meshNeighborsGroundwaterFlowRate, double* meshNeighborsGroundwaterCumulativeFlow,
                              double* channelNeighborsSurfacewaterFlowRate, double* channelNeighborsSurfacewaterCumulativeFlow,
                              double* channelNeighborsGroundwaterFlowRate, double* channelNeighborsGroundwaterCumulativeFlow);

  // Receive a state message from a mesh element and update the values for that
  // element in the file manager's variables.
  //
  // Parameters:
  //
  // element                                    - The element that is reporting
  //                                              its state.
  // surfacewaterDepth                          - channel element state.
  // surfacewaterError                          - channel element state.
  // precipitation                              - channel element state.
  // precipitationCumulative                    - channel element state.
  // evaporation                                - channel element state.
  // evaporationCumulative                      - channel element state.
  // evapoTranspirationState                    - channel element state.
  // channelNeighborsSurfacewaterFlowRate       - channel element state.
  // channelNeighborsSurfacewaterCumulativeFlow - channel element state.
  // meshNeighborsSurfacewaterFlowRate          - channel element state.
  // meshNeighborsSurfacewaterCumulativeFlow    - channel element state.
  // meshNeighborsGroundwaterFlowRate           - channel element state.
  // meshNeighborsGroundwaterCumulativeFlow     - channel element state.
  void handleChannelStateMessage(int element, double surfacewaterDepth, double surfacewaterError, double precipitation,
                                 double precipitationCumulative, double evaporation, double evaporationCumulative,
                                 EvapoTranspirationStateStruct evapoTranspirationState,
                                 double* channelNeighborsSurfacewaterFlowRate, double* channelNeighborsSurfacewaterCumulativeFlow,
                                 double* meshNeighborsSurfacewaterFlowRate, double* meshNeighborsSurfacewaterCumulativeFlow,
                                 double* meshNeighborsGroundwaterFlowRate, double* meshNeighborsGroundwaterCumulativeFlow);
  
  // These arrays are used to record when vertex data and state update messages are received.
  BoolArrayMMN* meshVertexUpdated;
  BoolArrayCV*  channelVertexUpdated;
  bool*         meshElementUpdated;
  bool*         channelElementUpdated;
};

#endif // __FILE_MANAGER_H__
