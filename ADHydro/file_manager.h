#ifndef __FILE_MANAGER_H__
#define __FILE_MANAGER_H__

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wsign-compare"
#include "file_manager.decl.h"
#pragma GCC diagnostic warning "-Wsign-compare"

#include "mesh_element.h"
#include "channel_element.h"

typedef int    intarraymmn[MeshElement::meshNeighborsSize];           // Fixed size array of ints.     Size is mesh    mesh neighbors.
typedef bool   boolarraymmn[MeshElement::meshNeighborsSize];          // Fixed size array of bools.    Size is mesh    mesh neighbors.
typedef double doublearraymmn[MeshElement::meshNeighborsSize];        // Fixed size array of doubles.  Size is mesh    mesh neighbors.
typedef int    intarraymcn[MeshElement::channelNeighborsSize];        // Fixed size array of ints.     Size is mesh    channel neighbors.
typedef double doublearraymcn[MeshElement::channelNeighborsSize];     // Fixed size array of doubles.  Size is mesh    channel neighbors.
typedef int    intarrayxdmf[ChannelElement::channelVerticesSize + 2]; // Fixed size array of ints.     Size is channel vertices + 2.  This is used only for
                                                                      // channelElementVertices.  See the comment of that variable for explanation.
typedef double doublearraycvn[ChannelElement::channelVerticesSize];   // Fixed size array of doubles.  Size is channel vertices.
typedef int    intarrayccn[ChannelElement::channelNeighborsSize];     // Fixed size array of ints.     Size is channel channel neighbors.
typedef int    intarraycmn[ChannelElement::meshNeighborsSize];        // Fixed size array of ints.     Size is channel mesh neighbors.
typedef double doublearraycmn[ChannelElement::meshNeighborsSize];     // Fixed size array of doubles.  Size is channel mesh neighbors.

// The group of file managers acts as an in-memory cache for values that are
// read from and written to NetCDF files.  Reading and writing individual
// values from NetCDF files is too slow.  We need to read and write large
// blocks from the arrays in the NetCDF files.  However, individual values are
// needed by mesh and channel elements.  The file manager group does the block
// reads and writes and makes the values available to the elements.
//
// At initialization, each file manager takes ownership of a block of each
// array containing the data for the elements that get assigned to its
// processor by the default Charm++ block mapping of array elements to
// processors.  This way, elements can initialize themselves without any
// message passing by getting a pointer to the file manager local branch and
// accessing its public member variables.
//
// After initialization, array elements might migrate away from the file
// manager local branch that owns their data.  We do not transfer ownership of
// the data between file manager local branches.  Instead, message passing is
// used to update data after initialization.
class FileManager : public CBase_FileManager
{
  FileManager_SDAG_CODE
  
public:

  // Calculate which file manager owns a given item.  The first
  // (globalNumberOfItems % CkNumPes()) file managers each have
  // (globalNumberOfItems / CkNumPes() + 1) items.  The remaining file managers
  // each have (globalNumberOfItems / CkNumPes()) items.
  //
  // Returns: the index of the file manager that owns item.
  //
  // Parameters:
  //
  // item                - The index of this item.
  // globalNumberOfItems - The total number of this kind of item.
  static int home(int item, int globalNumberOfItems);
  
  // Constructor.  Reads whatever variables are available from NetCDF files.
  // If a variable is not available from NetCDF files the file managers attempt
  // To derive it from other variables, for example element center coordinates
  // from element vertex coordinates.  If a variable is not available and
  // cannot be derived its array is unallocated and set to NULL.
  //
  // After initialization the file managers write out the initial state
  // including all derived variables to a separate set of NetCDF files that
  // will hold all of the simulation's output.  When writing is done the file
  // managers contribute to an empty reduction.
  //
  // Parameters:
  //
  // inputDirectorySize  - The size of the array passed to inputDirectory.
  // inputDirectory      - Where to find the NetCDF files to read.
  // outputDirectorySize - The size of the array passed to outputDirectory.
  // outputDirectory     - Where to create the NetCDF files to write.
  // geometryGroup       - The group to read and write in geometry.nc.
  // parameterGroup      - The group to read and write in parameter.nc.
  // stateGroup          - The group to read and write in state.nc.
  // time                - The current time to write to state.nc.
  // dt                  - The timestep to write to state.nc.
  FileManager(size_t inputDirectorySize, char* inputDirectory, size_t outputDirectorySize, char* outputDirectory, int geometryGroup,
              int parameterGroup, int stateGroup, double time, double dt);

  int globalNumberOfMeshNodes;       // Number of mesh nodes across all file managers.
  int localMeshNodeStart;            // Index of first mesh node owned by this local branch.
  int localNumberOfMeshNodes;        // Number of mesh nodes owned by this local branch.
  int globalNumberOfMeshElements;    // Number of mesh elements across all file managers.
  int localMeshElementStart;         // Index of first mesh element owned by this local branch.
  int localNumberOfMeshElements;     // Number of mesh elements owned by this local branch.
  int globalNumberOfChannelNodes;    // Number of channel nodes across all file managers.
  int localChannelNodeStart;         // Index of first channel node owned by this local branch.
  int localNumberOfChannelNodes;     // Number of channel nodes owned by this local branch.
  int globalNumberOfChannelElements; // Number of channel elements across all file managers.
  int localChannelElementStart;      // Index of first channel element owned by this local branch.
  int localNumberOfChannelElements;  // Number of channel elements owned by this local branch.
  
  // The following are pointers to dynamically allocated arrays containing the
  // data owned by this local branch.  The pointers can be NULL indicating the
  // data is not available.  Elements must check that the data they need to
  // initialize themselves are available.
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* meshNodeX;
  double* meshNodeY;
  double* meshNodeZSurface;
  double* meshNodeZBedrock;
  
  // This array stores the node indices of the vertices of each element.
  intarraymmn* meshElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Even this information is not used directly by the elements.  Instead, each
  // local branch calculates element values dervied from the vertex coordinates.
  doublearraymmn* meshVertexX;
  doublearraymmn* meshVertexY;
  doublearraymmn* meshVertexZSurface;
  doublearraymmn* meshVertexZBedrock;
  
  // These arrays store the values used directly by the elements.
  double*         meshElementX;
  double*         meshElementY;
  double*         meshElementZSurface;
  double*         meshElementZBedrock;
  double*         meshElementArea;
  double*         meshElementSlopeX;
  double*         meshElementSlopeY;
  int*            meshCatchment;
  double*         meshConductivity;
  double*         meshPorosity;
  double*         meshManningsN;
  double*         meshSurfacewaterDepth;
  double*         meshSurfacewaterError;
  double*         meshGroundwaterHead;
  double*         meshGroundwaterError;
  intarraymmn*    meshMeshNeighbors;
  boolarraymmn*   meshMeshNeighborsChannelEdge;
  doublearraymmn* meshMeshNeighborsEdgeLength;
  doublearraymmn* meshMeshNeighborsEdgeNormalX;
  doublearraymmn* meshMeshNeighborsEdgeNormalY;
  intarraymcn*    meshChannelNeighbors;
  doublearraymcn* meshChannelNeighborsEdgeLength;
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* channelNodeX;
  double* channelNodeY;
  double* channelNodeZBank;
  double* channelNodeZBed;
  
  // This array stores the node indices of the vertices of each element, but
  // with some special properties required for display as an XDMF file.
  // We want to display streams as polylines and waterbodies as polygons.
  // In XDMF this requires a mixed topology.  In a mixed topology, each element
  // must store its shape type, either 2 for polyline or 3 for polygon, and
  // number of vertices followed by the node indices of the vertices.  In order
  // for the mixed topology to work with the rectangular arrays of NetCDF files
  // all elements must have the same number of vertices.  Therefore,
  // channelElementVertices[n][0] is the shape type, always 2 or 3,
  // channelElementVertices[n][1] is the number of vertices, always
  // ChannelElement::channelVerticesSize, and the remaining values are the node
  // indices of ther vertices with channelElementVertices[n][2] holding vertex
  // 0, channelElementVertices[n][3] holding vertex 1, etc.  If a shape has
  // fewer vertices than ChannelElement::channelVerticesSize then the last
  // vertex is repeated as necessary.
  intarrayxdmf* channelElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Currently, this information is not used at all.  Channel element
  // information is derived in preprocessing and there is no code in the file
  // manager for deriving that information from vertices.  That could change in
  // the future.
  doublearraycvn* channelVertexX;
  doublearraycvn* channelVertexY;
  doublearraycvn* channelVertexZBank;
  doublearraycvn* channelVertexZBed;
  
  // These arrays store the values used directly by the elements.
  double*          channelElementX;
  double*          channelElementY;
  double*          channelElementZBank;
  double*          channelElementZBed;
  double*          channelElementLength;
  ChannelTypeEnum* channelChannelType;
  int*             channelPermanentCode;
  double*          channelBaseWidth;
  double*          channelSideSlope;
  double*          channelBedConductivity;
  double*          channelBedThickness;
  double*          channelManningsN;
  double*          channelSurfacewaterDepth;
  double*          channelSurfacewaterError;
  intarrayccn*     channelChannelNeighbors;
  intarraycmn*     channelMeshNeighbors;
  doublearraycmn*  channelMeshNeighborsEdgeLength;
  
private:
  
  // Calculate which items this file manager owns.  The first
  // (globalNumberOfItems % CkNumPes()) file managers each have
  // (globalNumberOfItems / CkNumPes() + 1) items.  The remaining file managers
  // each have (globalNumberOfItems / CkNumPes()) items.
  //
  // Parameters:
  //
  // localItemStart      - Scalar passed by reference will be filled in with
  //                       the local start index.
  // localNumberOfItems  - Scalar passed by reference will be filled in with
  //                       the local number of items.
  // globalNumberOfItems - The total number of this kind of item.
  static void localStartAndNumber(int* localItemStart, int* localNumberOfItems, int globalNumberOfItems);
  
  // Called at the end of the constructor or after getting vertex data from
  // node data if necessary.  Completes the work of the constructor by
  // calculating variables that can be derived from other variables, writing
  // out the initial state including all derived variables to NetCDF files and
  // contributing to an empty reduction.
  //
  // Parameters:
  //
  // directory      - Where to create the NetCDF files to write.
  // geometryGroup  - The group to write in geometry.nc.
  // parameterGroup - The group to write in parameter.nc.
  // stateGroup     - The group to write in state.nc.
  // time           - The current time to write to state.nc.
  // dt             - The timestep to write to state.nc.
  void calculateDerivedValues(char* directory, int geometryGroup, int parameterGroup, int stateGroup, double time, double dt);

  // Returns: true if all vertex information is updated, false otherwise.
  bool allVerticesUpdated();
  
  // Returns: true if all element information is updated, false otherwise.
  bool allElementsUpdated();
  
  // Write out values stored in arrays to geometry.nc file.
  //
  // Parameters:
  //
  // directory - The location of the file.
  // group     - The name of the group to create in the NetCDF file.
  //             It is an error if the group exists.
  // create    - Whether to create a new file.
  //             If true, it is an error if the file exists.
  //             If false, it is an error if the file does not exist.
  bool writeGeometry(const char* directory, int group, bool create);
  
  // Write out values stored in arrays to parameter.nc file.
  //
  // Parameters:
  //
  // directory - The location of the file.
  // group     - The name of the group to create in the NetCDF file.
  //             It is an error if the group exists.
  // create    - Whether to create a new file.
  //             If true, it is an error if the file exists.
  //             If false, it is an error if the file does not exist.
  bool writeParameter(const char* directory, int group, bool create);
  
  // Write out values stored in arrays to state.nc file.
  //
  // Parameters:
  //
  // directory      - The location of the file.
  // group          - The name of the group to create in the NetCDF file.
  //                  It is an error if the group exists.
  // create         - Whether to create a new file.
  //                  If true, it is an error if the file exists.
  //                  If false, it is an error if the file does not exist.
  // time           - The time to store in the group attributes.
  // dt             - The timestep to store in the group attributes.
  // geometryGroup  - The associated geometry group to store in the group
  //                  attributes.
  // parameterGroup - The associated parameter group to store in the group
  //                  attributes.
  bool writeState(const char* directory, int group, bool create, double time, double dt, int geometryGroup, int parameterGroup);
  
  // These arrays are used to record when vertex data and state update messages are received.
  boolarraymmn* meshVertexUpdated;
  bool*         meshElementUpdated;
  bool*         channelElementUpdated;
};

#endif // __FILE_MANAGER_H__
