#include "region.h"

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wsign-compare"
#include "region.def.h"
#pragma GCC diagnostic warning "-Wsign-compare"

bool Region::checkInvariant() const
{
    bool                                             error = false; // Error flag.
    std::map<size_t,    MeshElement>::const_iterator itMesh;        // Loop iterator.
    std::map<size_t, ChannelElement>::const_iterator itChannel;     // Loop iterator.
    
    if (!(currentTime <= timestepEndTime && timestepEndTime <= simulationEndTime)) // FIXME timestepEndTime <= nextSyncTime <= simulationEndTime
    {
        CkError("ERROR in Region::checkInvariant: currentTime must be less than or equal to timestepEndTime, which must be less than or equal to simulationEndTime.\n");
        error = true;
    }
    
    for (itMesh = meshElements.begin(); itMesh != meshElements.end(); ++itMesh)
    {
        if (!(itMesh->second.getElementNumber() == itMesh->first))
        {
            CkError("ERROR in Region::checkInvariant: mesh element %lu stored at map key %lu.\n", itMesh->second.getElementNumber(), itMesh->first);
            error = true;
        }
        
        error = itMesh->second.checkInvariant() || error;
    }
    
    for (itChannel = channelElements.begin(); itChannel != channelElements.end(); ++itChannel)
    {
        if (!(itChannel->second.getElementNumber() == itChannel->first))
        {
            CkError("ERROR in Region::checkInvariant: channel element %lu stored at map key %lu.\n", itChannel->second.getElementNumber(), itChannel->first);
            error = true;
        }
        
        error = itChannel->second.checkInvariant() || error;
    }
    
    if (!(meshElements.size() + channelElements.size() >= elementsFinished))
    {
        CkError("ERROR in Region::checkInvariant: elementsFinished must be less than or equal to meshElements.size() plus channelElements.size().\n");
        error = true;
    }
    
    return error;
}

void Region::receiveNeighborAttributes(std::vector<NeighborMessage>& messages)
{
    std::vector<NeighborMessage>::iterator it; // Loop iterator.
    
    // Don't error check parameters because it's a simple pass-through to MeshElement::receiveNeighborAttributes or ChannelElement::receiveNeighborAttributes and it will be checked inside that method.
    
    // Loop over messages passing the NeighborMessage objects to elements.
    for (it = messages.begin(); it != messages.end(); ++it)
    {
        // Now that the message has arrived at its destination the old remote neighbor is now the local neighbor and the old local neighbor is now the remote neighbor.
        it->destination.reverse();
        
        // Pass the StateMessage to the appropriate element.
        if (findElement(it->destination.localEndpoint, it->destination.localElementNumber).receiveNeighborAttributes(elementsFinished, *it))
        {
            CkExit();
        }
    }
}

void Region::receiveState(std::vector<StateMessage>& messages)
{
    std::vector<StateMessage>::iterator it; // Loop iterator.
    
    // Don't error check parameters because it's a simple pass-through to MeshElement::receiveState or ChannelElement::receiveState and it will be checked inside that method.
    
    // Loop over messages passing the StateMessage objects to elements.
    for (it = messages.begin(); it != messages.end(); ++it)
    {
        // Now that the message has arrived at its destination the old remote neighbor is now the local neighbor and the old local neighbor is now the remote neighbor.
        it->destination.reverse();
        
        // Pass the StateMessage to the appropriate element.
        if (findElement(it->destination.localEndpoint, it->destination.localElementNumber).receiveState(elementsFinished, *it, currentTime))
        {
            CkExit();
        }
    }
}

void Region::receiveWater(std::vector<WaterMessage>& messages)
{
    std::vector<WaterMessage>::iterator it; // Loop iterator.
    
    // Don't error check parameters because it's a simple pass-through to MeshElement::receiveWater or ChannelElement::receiveWater and it will be checked inside that method.
    
    // Loop over messages passing the WaterMessage objects to elements.
    for (it = messages.begin(); it != messages.end(); ++it)
    {
        // Now that the message has arrived at its destination the old remote neighbor is now the local neighbor and the old local neighbor is now the remote neighbor.
        it->destination.reverse();
        
        // Pass the WaterMessage to the appropriate element.
        if (findElement(it->destination.localEndpoint, it->destination.localElementNumber).receiveWater(elementsFinished, *it, currentTime, timestepEndTime))
        {
            CkExit();
        }
    }
}

Element& Region::findElement(NeighborEndpointEnum localEndpoint, size_t localElementNumber)
{
    std::map<size_t,    MeshElement>::iterator itMesh;    // Iterator for finding correct MeshElement.
    std::map<size_t, ChannelElement>::iterator itChannel; // Iterator for finding correct ChannelElement.
    
    switch (localEndpoint)
    {
        case MESH_SURFACE:
        case MESH_SOIL:
        case MESH_AQUIFER:
        case IRRIGATION_RECIPIENT:
            itMesh = meshElements.find(localElementNumber);
            
            if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
            {
                if (!(meshElements.end() != itMesh))
                {
                    CkError("ERROR in Region::findElement: trying to find mesh element %lu that I do not have.\n", localElementNumber);
                    CkExit();
                }
            }
            
            return itMesh->second;
            break;
        case CHANNEL_SURFACE:
        case RESERVOIR_RELEASE:
        case RESERVOIR_RECIPIENT:
        case IRRIGATION_DIVERSION:
            itChannel = channelElements.find(localElementNumber);
            
            if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
            {
                if (!(channelElements.end() != itChannel))
                {
                    CkError("ERROR in Region::findElement: trying to find channel element %lu that I do not have.\n", localElementNumber);
                    CkExit();
                }
            }
            
            return itChannel->second;
            break;
        default:
            if (DEBUG_LEVEL & DEBUG_LEVEL_PUBLIC_FUNCTIONS_SIMPLE)
            {
                CkError("ERROR in Region::findElement: invalid localEndpoint %d.\n", localEndpoint);
                CkExit();
            }
            
            return meshElements.begin()->second; // This is wrong, but it's just here to avoid a control reaches end of non-void function warning.
            break;
    }
}
