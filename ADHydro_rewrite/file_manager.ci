module file_manager
{
  group FileManager
  {
    entry [reductiontarget] void printOutMassBalance(double waterInDomain, double externalFlows, double waterError);
    
    entry FileManager();
    
    // Dummy function for structured dagger infinite loop.
    entry void runUntilSimulationEnd()
    {
      serial
      {
        // Initialize Noah-MP.
        evapoTranspirationInit(ADHydro::evapoTranspirationInitMpTableFilePath.c_str(),  ADHydro::evapoTranspirationInitVegParmFilePath.c_str(),
                               ADHydro::evapoTranspirationInitSoilParmFilePath.c_str(), ADHydro::evapoTranspirationInitGenParmFilePath.c_str());
        
        // Read input files.
        if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
          {
            CkPrintf("Reading input files.\n");
          }
        
        if (ADHydro::initializeFromASCIIFiles)
          {
            initializeFromASCIIFiles();
          }
        else
          {
            initializeFromNetCDFFiles();
          }
        
        // Calculating derived values may require getting vertex data from other file managers.  If it is not required allVerticesUpdated will immediately
        // return true.
        updateVertices();
      }
      
      while (!allVerticesUpdated())
      {
        case
        {
          when meshVertexDataMessage(int node, double x, double y, double zSurface)
          {
            serial
            {
              handleMeshVertexDataMessage(node, x, y, zSurface);
            }
          }
          
          when channelVertexDataMessage(int node, double x, double y, double zBank)
          {
            serial
            {
              handleChannelVertexDataMessage(node, x, y, zBank);
            }
          }
        }
      }
      
      serial
      {
        // Then the file manager must calculate derived values.
        calculateDerivedValues();
        
        if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
          {
            CkPrintf("Finished reading input files.\n");
          }
        
        // File manager 0 creates the region array, sets up its default reduction client, and sends its proxy out to all of the file managers.
        if (0 == CkMyPe())
          {
#if (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_SIMPLE)
            if (!(0 < globalNumberOfRegions))
              {
                CkError("ERROR in FileManager::runUntilSimulationEnd: globalNumberOfRegions must be greater than zero.\n");
                CkExit();
              }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_SIMPLE)
            
            ADHydro::regionProxy = CProxy_Region::ckNew(ADHydro::referenceDate, currentTime, simulationEndTime, globalNumberOfRegions);
            
            ADHydro::regionProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(FileManager, printOutMassBalance), thisProxy[0]));
            
            thisProxy.sendInitializationMessages(ADHydro::regionProxy);
          }
      }
      
      // Send out messages to initialize all elements.
      when sendInitializationMessages(CProxy_Region regionProxy)
      {
        serial
        {
          handleSendInitializationMessages(regionProxy);
        }
      }
      
      // Receive state updates and output to file until simulation is finished.
      while (!simulationFinished)
      {
        serial
        {
          // Write output files.
          if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
            {
              CkPrintf("Writing output files for time %.0lf.\n", currentTime);
            }
          
          writeNetCDFFiles();
          
          if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
            {
              CkPrintf("Finished writing output files.\n");
            }
        }
        
        if (currentTime == simulationEndTime)
        {
          serial
          {
            simulationFinished = true;
          }
        }
        else // if (currentTime < simulationEndTime)
        {
          serial
          {
            int ii; // Loop counter.
            
            // Advance time.
            if (nextCheckpointIndex * ADHydro::checkpointPeriod == currentTime)
              {
                ++nextCheckpointIndex;
              }
            
            if (nextOutputIndex * ADHydro::outputPeriod == currentTime)
              {
                ++nextOutputIndex;
              }
            
            currentTime = nextCheckpointIndex * ADHydro::checkpointPeriod;
            
            if (currentTime > nextOutputIndex * ADHydro::outputPeriod)
              {
                currentTime = nextOutputIndex * ADHydro::outputPeriod;
              }
            
            if (currentTime > simulationEndTime)
              {
                currentTime = simulationEndTime;
              }
            
            // Set all element state to not updated.
            for (ii = 0; ii < localNumberOfMeshElements; ++ii)
              {
                meshElementUpdated[ii] = false;
              }
            
            for (ii = 0; ii < localNumberOfChannelElements; ++ii)
              {
                channelElementUpdated[ii] = false;
              }
          }
          
          while (!allStateUpdated())
          {
            // Receive state updates.
            when sendElementStateMessages(double messageTime, std::vector<ElementStateMessage> meshElementStateMessages,
                                          std::vector<ElementStateMessage> channelElementStateMessages)
            {
              serial
              {
                std::vector<ElementStateMessage>::iterator it; // For looping over state messages.
                
                if (messageTime > currentTime)
                  {
                    // Message from the future.  Don't receive yet.
                    thisProxy[CkMyPe()].sendElementStateMessages(messageTime, meshElementStateMessages, channelElementStateMessages);
                  }
                else if (messageTime == currentTime)
                  {
                    for (it = meshElementStateMessages.begin(); it != meshElementStateMessages.end(); ++it)
                      {
                        handleMeshElementStateMessage(*it);
                      }
                    
                    for (it = channelElementStateMessages.begin(); it != channelElementStateMessages.end(); ++it)
                      {
                        handleChannelElementStateMessage(*it);
                      }
                  }
#if (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
                else
                  {
                    CkError("ERROR in FileManager::runUntilSimulationEnd: state message received from the past.  This should never happen.\n");
                    CkExit();
                  }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
              }
            }
          }
        } // End else if (currentTime < simulationEndTime)
      } // End while (!simulationFinished)
      
      // FIXME wait until last mass balance is done and then exit.
    }; // End entry void runUntilSimulationEnd().
    
    entry void getMeshVertexDataMessage(int requester, int node);
    entry void getChannelVertexDataMessage(int requester, int node);
    entry void meshVertexDataMessage(int node, double x, double y, double zSurface);
    entry void channelVertexDataMessage(int node, double x, double y, double zBank);
    entry void sendInitializationMessages(CProxy_Region regionProxy);
    entry void sendElementStateMessages(double messageTime, std::vector<ElementStateMessage> meshElementStateMessages,
                                        std::vector<ElementStateMessage> channelElementStateMessages);
  }; // End group FileManager.
}; // End module file_manager.
