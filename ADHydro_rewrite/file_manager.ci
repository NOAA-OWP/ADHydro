module file_manager
{
  group FileManager
  {
    entry [reductiontarget] void printOutMassBalance(double messageTime, double waterInDomain, double externalFlows, double waterError);
    
    entry FileManager();
    
    // Dummy function for structured dagger infinite loop.
    entry void runUntilSimulationEnd()
    {
      serial
      {
        // Initialize Noah-MP.
        evapoTranspirationInit(ADHydro::evapoTranspirationInitMpTableFilePath.c_str(),  ADHydro::evapoTranspirationInitVegParmFilePath.c_str(),
                               ADHydro::evapoTranspirationInitSoilParmFilePath.c_str(), ADHydro::evapoTranspirationInitGenParmFilePath.c_str());
        
        // Read input files.
        if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
          {
            CkPrintf("Reading input files.\n");
          }
        
        if (ADHydro::initializeFromASCIIFiles)
          {
            initializeFromASCIIFiles();
          }
        else
          {
            initializeFromNetCDFFiles();
          }
        
        // Calculating derived values may require getting vertex data from other file managers.  If it is not required allVerticesUpdated will immediately
        // return true.
        updateVertices();
      }
      
      while (!allVerticesUpdated())
      {
        case
        {
          when meshVertexDataMessage(int node, double x, double y, double zSurface)
          {
            serial
            {
              handleMeshVertexDataMessage(node, x, y, zSurface);
            }
          }
          
          when channelVertexDataMessage(int node, double x, double y, double zBank)
          {
            serial
            {
              handleChannelVertexDataMessage(node, x, y, zBank);
            }
          }
        }
      }
      
      serial
      {
        // Then the file manager must calculate derived values.
        calculateDerivedValues();
        
        if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
          {
            CkPrintf("Finished reading input files.\n");
          }
        
        // File manager 0 creates the region array, sets up its default reduction client, and sends its proxy out to all of the file managers.
        if (0 == CkMyPe())
          {
#if (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_SIMPLE)
            if (!(0 < globalNumberOfRegions))
              {
                CkError("ERROR in FileManager::runUntilSimulationEnd: globalNumberOfRegions must be greater than zero.\n");
                CkExit();
              }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_USER_INPUT_SIMPLE)
            
            // Create the chare array of regions.
            ADHydro::regionProxy = CProxy_Region::ckNew(ADHydro::referenceDate, currentTime, simulationEndTime, globalNumberOfRegions);
            
            // Regions use a reduction to do mass balance.
            ADHydro::regionProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(FileManager, printOutMassBalance), thisProxy[0]));
            
            // File managers use a reduction as a barrier before writing to NetCDF files.
            thisProxy.ckSetReductionClient(new CkCallback(CkReductionTarget(FileManager, barrier), thisProxy));
            
            thisProxy.sendInitializationMessages(ADHydro::regionProxy);
          }
      }
      
      // Send out messages to initialize all elements.
      when sendInitializationMessages(CProxy_Region regionProxy)
      {
        serial
        {
          handleSendInitializationMessages(regionProxy);
        }
      }
      
      // Receive state updates and output to file until simulation is finished.
      while (!simulationFinished)
      {
        serial
        {
          // Write output files.
          if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
            {
              long   simulationYear;   // For calculating Gregorian date from Julian date.
              long   simulationMonth;  // For calculating Gregorian date from Julian date.
              long   simulationDay;    // For calculating Gregorian date from Julian date.
              long   simulationHour;   // For calculating Gregorian date from Julian date.
              long   simulationMinute; // For calculating Gregorian date from Julian date.
              double simulationSecond; // For calculating Gregorian date from Julian date.
              
              julianToGregorian(ADHydro::referenceDate + currentTime / (24.0 * 3600.0), &simulationYear, &simulationMonth, &simulationDay, &simulationHour,
                                &simulationMinute, &simulationSecond);

              CkPrintf("Writing output files for simulation time %.0lf, date %02d/%02d/%04d %02d:%02d:%02.0lf UTC.\n", currentTime, simulationMonth,
                       simulationDay, simulationYear, simulationHour, simulationMinute, simulationSecond);
            }
          
          // There is a potential deadlock problem that requires a barrier here.  Opening NetCDF files in parallel hits a barrier in the NetCDF library, which
          // waits for all other file managers to hit the barrier.  Because Charm++ is single threaded on each PE, when a file manager enters writeNetCDFFiles
          // and hits that barrier no further Charm++ operations can take place on that PE until all file managers reach the NetCDF barrier.  But there may be
          // another file manager that is waiting for a state message from a region that has migrated to that PE, and that message will never be sent because
          // that PE is locked by the file manager waiting at the NetCDF barrier.  The solution is to put a Charm++ barrier (implemented as a reduction) before
          // the NetCDF barrier because the Charm++ barrier is implemented in such a way that other Charm++ operations can continue while a file manager is
          // waiting at the barrier.
          contribute();
        }
        
        when barrier()
        {
          serial
          {
            writeNetCDFFiles();
            
            if (0 == CkMyPe() && 1 <= ADHydro::verbosityLevel)
              {
                CkPrintf("Finished writing output files.\n");
              }
          }
        }
        
        if (currentTime == simulationEndTime)
        {
          serial
          {
            simulationFinished = true;
          }
        }
        else // if (currentTime < simulationEndTime)
        {
          serial
          {
            int ii; // Loop counter.
            
            // Advance time.
            if (nextCheckpointIndex * ADHydro::checkpointPeriod == currentTime)
              {
                ++nextCheckpointIndex;
              }
            
            if (nextOutputIndex * ADHydro::outputPeriod == currentTime)
              {
                ++nextOutputIndex;
              }
            
            currentTime = nextCheckpointIndex * ADHydro::checkpointPeriod;
            
            if (currentTime > nextOutputIndex * ADHydro::outputPeriod)
              {
                currentTime = nextOutputIndex * ADHydro::outputPeriod;
              }
            
            if (currentTime > simulationEndTime)
              {
                currentTime = simulationEndTime;
              }
            
            // Set all element state to not updated.
            for (ii = 0; ii < localNumberOfMeshElements; ++ii)
              {
                meshElementUpdated[ii] = false;
              }
            
            for (ii = 0; ii < localNumberOfChannelElements; ++ii)
              {
                channelElementUpdated[ii] = false;
              }
          }
          
          while (!allStateUpdated())
          {
            // Receive state updates.
            when sendElementStateMessages(double messageTime, std::vector<ElementStateMessage> meshElementStateMessages,
                                          std::vector<ElementStateMessage> channelElementStateMessages)
            {
              serial
              {
                std::vector<ElementStateMessage>::iterator it; // For looping over state messages.
                
                if (messageTime > currentTime)
                  {
                    // Message from the future.  Don't receive yet.
                    thisProxy[CkMyPe()].sendElementStateMessages(messageTime, meshElementStateMessages, channelElementStateMessages);
                  }
                else if (messageTime == currentTime)
                  {
                    for (it = meshElementStateMessages.begin(); it != meshElementStateMessages.end(); ++it)
                      {
                        handleMeshElementStateMessage(*it);
                      }
                    
                    for (it = channelElementStateMessages.begin(); it != channelElementStateMessages.end(); ++it)
                      {
                        handleChannelElementStateMessage(*it);
                      }
                  }
#if (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
                else
                  {
                    CkError("ERROR in FileManager::runUntilSimulationEnd: state message received from the past.  This should never happen.\n");
                    CkExit();
                  }
#endif // (DEBUG_LEVEL & DEBUG_LEVEL_INTERNAL_SIMPLE)
              }
            }
          }
        } // End else if (currentTime < simulationEndTime)
      } // End while (!simulationFinished)
      
      // On PE zero wait for the last mass balance reduction to finish before exiting.
      while (0 == CkMyPe() && massBalanceTime != simulationEndTime)
      {
        when massBalanceDone()
        {
          // No-op.
        }
      }
      
      // Wait until all file managers finish before exiting.
      serial
      {
        contribute(CkCallback(CkCallback::ckExit));
      }
    }; // End entry void runUntilSimulationEnd().
    
    entry void getMeshVertexDataMessage(int requester, int node);
    entry void getChannelVertexDataMessage(int requester, int node);
    entry void meshVertexDataMessage(int node, double x, double y, double zSurface);
    entry void channelVertexDataMessage(int node, double x, double y, double zBank);
    entry void sendInitializationMessages(CProxy_Region regionProxy);
    entry void sendElementStateMessages(double messageTime, std::vector<ElementStateMessage> meshElementStateMessages,
                                        std::vector<ElementStateMessage> channelElementStateMessages);
    entry void massBalanceDone();
    entry [reductiontarget] void barrier();
  }; // End group FileManager.
}; // End module file_manager.
