#ifndef __FILE_MANAGER_H__
#define __FILE_MANAGER_H__

#include "region.h"

// Suppress warnings in the The Charm++ autogenerated code.
#pragma GCC diagnostic ignored "-Wsign-compare"
#include "file_manager.decl.h"
#pragma GCC diagnostic warning "-Wsign-compare"

// MESH_ELEMENT_VERTICES_SIZE is always equal to MESH_ELEMENT_MESH_NEIGHBORS_SIZE
#define MESH_ELEMENT_MESH_NEIGHBORS_SIZE (3)
#define MESH_ELEMENT_CHANNEL_NEIGHBORS_SIZE (2)
#define CHANNEL_ELEMENT_VERTICES_SIZE (10)
#define XDMF_SIZE (CHANNEL_ELEMENT_VERTICES_SIZE + 2) // channelElementVertices must have two extra values of XDMF metadata.
#define CHANNEL_ELEMENT_MESH_NEIGHBORS_SIZE (2)
#define CHANNEL_ELEMENT_CHANNEL_NEIGHBORS_SIZE (2)

typedef int    IntArrayMMN[MESH_ELEMENT_MESH_NEIGHBORS_SIZE];          // Fixed size array of ints.    Size is mesh    mesh neighbors.
typedef double DoubleArrayMMN[MESH_ELEMENT_MESH_NEIGHBORS_SIZE];       // Fixed size array of doubles. Size is mesh    mesh neighbors.
typedef int    IntArrayMCN[MESH_ELEMENT_CHANNEL_NEIGHBORS_SIZE];       // Fixed size array of ints.    Size is mesh    channel neighbors.
typedef double DoubleArrayMCN[MESH_ELEMENT_CHANNEL_NEIGHBORS_SIZE];    // Fixed size array of doubles. Size is mesh    channel neighbors.
typedef int    IntArrayXDMF[XDMF_SIZE];                                // Fixed size array of ints.    Size is channel vertices + 2.  This is used only for
                                                                       // channelElementVertices.  See the comment of that variable for explanation.
typedef double DoubleArrayCV[CHANNEL_ELEMENT_VERTICES_SIZE];           // Fixed size array of doubles. Size is channel vertices.
typedef int    IntArrayCMN[CHANNEL_ELEMENT_MESH_NEIGHBORS_SIZE];       // Fixed size array of ints.    Size is channel mesh neighbors.
typedef double DoubleArrayCMN[CHANNEL_ELEMENT_MESH_NEIGHBORS_SIZE];    // Fixed size array of doubles. Size is channel mesh neighbors.
typedef int    IntArrayCCN[CHANNEL_ELEMENT_CHANNEL_NEIGHBORS_SIZE];    // Fixed size array of ints.    Size is channel channel neighbors.
typedef double DoubleArrayCCN[CHANNEL_ELEMENT_CHANNEL_NEIGHBORS_SIZE]; // Fixed size array of doubles. Size is channel channel neighbors.

// The group of file managers acts as an in-memory cache for values that are
// read from and written to NetCDF files.  Reading and writing individual
// values from NetCDF files is too slow.  We need to read and write large
// blocks from the arrays in the NetCDF files.  However, individual values are
// needed by mesh and channel elements.  The file manager group does the block
// reads and writes and makes the individual values available to the elements.
//
// At initialization, each file manager takes ownership of a block of each
// array.  This gives each file manager ownership of the information about a
// set of elements.  Then each file manager sends initialization messages for
// the elements it owns.  At output intervals, each element sends a state
// update back to the file manager that owns it.  When all of the state updates
// have been received the file managers collectively write the arrays to file.
class FileManager : public CBase_FileManager
{
  FileManager_SDAG_CODE
  
public:
  
  // Print out the mass balance check.  This is a reduction target that
  // collects all mass balance values from the entire mesh.  To calculate the
  // mass balance take waterInDomain and add externalFlows and subtract
  // waterError.  This will undo any insertion or removal of water from the
  // "black box" of the simulation domain leaving the amount of water that was
  // present when externalFlows and waterError were both zero.  This value
  // should be invariant except for floating point roundoff error.
  //
  // Parameters:
  //
  // waterInDomain - The amount of water in cubic meters in the entire mesh.
  //                 Positive means the existance of water.  Must be
  //                 non-negative.
  // externalFlows - The amount of water in cubic meters that has flowed to or
  //                 from external sources and sinks (boundary conditions,
  //                 precipitation, E-T, etc.) for the entire mesh.  Positive
  //                 means flow out of the mesh.  Negative means flow into
  //                 the mesh.
  // waterError    - The amount of water in cubic meters that was created or
  //                 destroyed be error in the entire mesh.  Positive means
  //                 water was created.  Negative means water was destroyed.
  static void printOutMassBalance(double waterInDomain, double externalFlows, double waterError);

  // Calculate which file manager owns a given item.  Items are generally mesh
  // elements, although this function can be used to distribute any set of
  // items among file managers.  The first (globalNumberOfItems % CkNumPes())
  // file managers each have (globalNumberOfItems / CkNumPes() + 1) items.
  // The remaining file managers each have (globalNumberOfItems / CkNumPes())
  // items.
  //
  // Returns: the index of the file manager that owns item.
  //
  // Parameters:
  //
  // item                - The index of this item.
  // globalNumberOfItems - The total number of this kind of item.
  static int home(int item, int globalNumberOfItems);
  
  // Constructor.  Initializes the file manager to hold no data and starts the
  // runUntilSimulationEnd function in the SDAG code.
  FileManager();
  
  // Destructor.  Dynamically allocated arrays need to be deleted.
  ~FileManager();
  
  int globalNumberOfRegions;         // Number of regions in entire chare array.
  int globalNumberOfMeshNodes;       // Number of mesh nodes across all file managers.
  int localMeshNodeStart;            // Index of first mesh node owned by this local branch.
  int localNumberOfMeshNodes;        // Number of mesh nodes owned by this local branch.
  int globalNumberOfMeshElements;    // Number of mesh elements across all file managers.
  int localMeshElementStart;         // Index of first mesh element owned by this local branch.
  int localNumberOfMeshElements;     // Number of mesh elements owned by this local branch.
  int globalNumberOfChannelNodes;    // Number of channel nodes across all file managers.
  int localChannelNodeStart;         // Index of first channel node owned by this local branch.
  int localNumberOfChannelNodes;     // Number of channel nodes owned by this local branch.
  int globalNumberOfChannelElements; // Number of channel elements across all file managers.
  int localChannelElementStart;      // Index of first channel element owned by this local branch.
  int localNumberOfChannelElements;  // Number of channel elements owned by this local branch.
  
  // The following are pointers to dynamically allocated arrays containing the
  // data owned by this local branch.  The pointers can be NULL indicating the
  // data is not available.  The arrays are indexed by a local index, which is
  // globalItemNumber - localItemStart where item can be MeshNode, MeshElement,
  // ChannelNode, or ChannelElement.
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* meshNodeX;
  double* meshNodeY;
  double* meshNodeZSurface;
  
  // This array stores the node indices of the vertices of each element.
  IntArrayMMN* meshElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Even this information is not used directly by the elements.  Instead, each
  // local branch calculates element values dervied from the vertex coordinates.
  DoubleArrayMMN* meshVertexX;
  DoubleArrayMMN* meshVertexY;
  DoubleArrayMMN* meshVertexZSurface;
  
  // These arrays store the values used directly by the elements.
  int*            meshRegion;
  int*            meshCatchment;
  int*            meshVegetationType;
  int*            meshSoilType;
  double*         meshElementX;
  double*         meshElementY;
  double*         meshElementZSurface;
  double*         meshElementSoilDepth;
  double*         meshElementLayerZBottom;
  double*         meshElementArea;
  double*         meshElementSlopeX;
  double*         meshElementSlopeY;
  double*         meshLatitude;
  double*         meshLongitude;
  double*         meshManningsN;
  double*         meshConductivity;
  double*         meshPorosity;
  double*         meshSurfacewaterDepth;
  double*         meshSurfacewaterError;
  double*         meshGroundwaterHead;
  double*         meshGroundwaterRecharge;
  double*         meshGroundwaterError;
  double*         meshPrecipitationRate;
  double*         meshPrecipitationCumulativeShortTerm;
  double*         meshPrecipitationCumulativeLongTerm;
  double*         meshEvaporationRate;
  double*         meshEvaporationCumulativeShortTerm;
  double*         meshEvaporationCumulativeLongTerm;
  double*         meshTranspirationRate;
  double*         meshTranspirationCumulativeShortTerm;
  double*         meshTranspirationCumulativeLongTerm;
  EvapoTranspirationStateStruct*
                  meshEvapoTranspirationState;
  InfiltrationAndGroundwater::InfiltrationMethodEnum*
                  meshInfiltrationMethod;
  InfiltrationAndGroundwater::GroundwaterMethodEnum*
                  meshGroundwaterMethod;
  IntArrayMMN*    meshSurfacewaterMeshNeighbors;
  IntArrayMMN*    meshSurfacewaterMeshNeighborsRegion;
  DoubleArrayMMN* meshSurfacewaterMeshNeighborsEdgeLength;
  DoubleArrayMMN* meshSurfacewaterMeshNeighborsEdgeNormalX;
  DoubleArrayMMN* meshSurfacewaterMeshNeighborsEdgeNormalY;
  DoubleArrayMMN* meshSurfacewaterMeshNeighborsFlowCumulativeShortTerm;
  DoubleArrayMMN* meshSurfacewaterMeshNeighborsFlowCumulativeLongTerm;
  IntArrayMCN*    meshSurfacewaterChannelNeighbors;
  IntArrayMCN*    meshSurfacewaterChannelNeighborsRegion;
  DoubleArrayMCN* meshSurfacewaterChannelNeighborsEdgeLength;
  DoubleArrayMCN* meshSurfacewaterChannelNeighborsFlowCumulativeShortTerm;
  DoubleArrayMCN* meshSurfacewaterChannelNeighborsFlowCumulativeLongTerm;
  IntArrayMMN*    meshGroundwaterMeshNeighbors;
  IntArrayMMN*    meshGroundwaterMeshNeighborsRegion;
  DoubleArrayMMN* meshGroundwaterMeshNeighborsEdgeLength;
  DoubleArrayMMN* meshGroundwaterMeshNeighborsEdgeNormalX;
  DoubleArrayMMN* meshGroundwaterMeshNeighborsEdgeNormalY;
  DoubleArrayMMN* meshGroundwaterMeshNeighborsFlowCumulativeShortTerm;
  DoubleArrayMMN* meshGroundwaterMeshNeighborsFlowCumulativeLongTerm;
  IntArrayMCN*    meshGroundwaterChannelNeighbors;
  IntArrayMCN*    meshGroundwaterChannelNeighborsRegion;
  DoubleArrayMCN* meshGroundwaterChannelNeighborsEdgeLength;
  DoubleArrayMCN* meshGroundwaterChannelNeighborsFlowCumulativeShortTerm;
  DoubleArrayMCN* meshGroundwaterChannelNeighborsFlowCumulativeLongTerm;
  
  // Nodes are a list of points indexed by node number.  A node may be a vertex
  // for multiple elements.  As such, it is not guaranteed that all of an
  // element's nodes are owned by a single local branch.  Therefore, they are
  // not directly used by the elements.  Instead, each local branch caches the
  // coordinates of the vertices of the elements it owns even though this
  // information is redundant.
  double* channelNodeX;
  double* channelNodeY;
  double* channelNodeZBank;
  
  // This array stores the node indices of the vertices of each element, but
  // with some extra metadata required for display as an XDMF file.  We want to
  // display streams as polylines and waterbodies as polygons.  In XDMF this
  // requires a mixed topology.  In a mixed topology, each element must store
  // its shape type, either 2 for polyline or 3 for polygon, and number of
  // vertices followed by the node indices of the vertices.  In order for the
  // mixed topology to work with the rectangular arrays of NetCDF files all
  // elements must have the same number of vertices.  Therefore,
  // channelElementVertices[n][0] is the shape type, always 2 or 3,
  // channelElementVertices[n][1] is the number of vertices, always
  // CHANNEL_ELEMENT_CHANNEL_VERTICES_SIZE, and the remaining values are the
  // node indices of the vertices with channelElementVertices[n][2] holding
  // vertex 0, channelElementVertices[n][3] holding vertex 1, etc.  If a shape
  // has fewer vertices than CHANNEL_ELEMENT_CHANNEL_VERTICES_SIZE then the
  // last vertex is repeated as necessary.
  IntArrayXDMF* channelElementVertices;
  
  // These arrays store the coordinates of the vertices of each element.
  // Even this information is not used directly by the elements.  Instead, each
  // local branch calculates element values dervied from the vertex coordinates.
  DoubleArrayCV* channelVertexX;
  DoubleArrayCV* channelVertexY;
  DoubleArrayCV* channelVertexZBank;
  
  // These arrays store the values used directly by the elements.
  int*             channelRegion;
  ChannelTypeEnum* channelChannelType;
  long long*       channelReachCode;
  double*          channelElementX;
  double*          channelElementY;
  double*          channelElementZBank;
  double*          channelElementBankFullDepth;
  double*          channelElementZBed;
  double*          channelElementLength;
  double*          channelBaseWidth;
  double*          channelSideSlope;
  double*          channelBedConductivity;
  double*          channelBedThickness;
  double*          channelManningsN;
  double*          channelSurfacewaterDepth;
  double*          channelSurfacewaterError;
  IntArrayCMN*     channelSurfacewaterMeshNeighbors;
  IntArrayCMN*     channelSurfacewaterMeshNeighborsRegion;
  DoubleArrayCMN*  channelSurfacewaterMeshNeighborsEdgeLength;
  DoubleArrayCMN*  channelSurfacewaterMeshNeighborsFlowCumulativeShortTerm;
  DoubleArrayCMN*  channelSurfacewaterMeshNeighborsFlowCumulativeLongTerm;
  IntArrayCCN*     channelSurfacewaterChannelNeighbors;
  IntArrayCCN*     channelSurfacewaterChannelNeighborsRegion;
  DoubleArrayCCN*  channelSurfacewaterChannelNeighborsFlowCumulativeShortTerm;
  DoubleArrayCCN*  channelSurfacewaterChannelNeighborsFlowCumulativeLongTerm;
  IntArrayCMN*     channelGroundwaterMeshNeighbors;
  IntArrayCMN*     channelGroundwaterMeshNeighborsRegion;
  DoubleArrayCMN*  channelGroundwaterMeshNeighborsEdgeLength;
  DoubleArrayCMN*  channelGroundwaterMeshNeighborsFlowCumulativeShortTerm;
  DoubleArrayCMN*  channelGroundwaterMeshNeighborsFlowCumulativeLongTerm;
  
private:
  
  // Calculate which items this file manager owns.  Items are generally mesh
  // elements, although this function can be used to distribute any set of
  // items among file managers.  The first (globalNumberOfItems % CkNumPes())
  // file managers each have (globalNumberOfItems / CkNumPes() + 1) items.
  // The remaining file managers each have (globalNumberOfItems / CkNumPes())
  // items.
  //
  // Parameters:
  //
  // localItemStart      - Scalar passed by reference will be filled in with
  //                       the local start index.
  // localNumberOfItems  - Scalar passed by reference will be filled in with
  //                       the local number of items.
  // globalNumberOfItems - The total number of this kind of item.
  static void localStartAndNumber(int* localItemStart, int* localNumberOfItems, int globalNumberOfItems);
  
  // FIXME comment
  void initializeFromASCIIFiles();
  
  // FIXME comment
  void initializeFromNetCDFFiles();
  
  // FIXME remove
  void setUpHardcodedMesh();
  
  // FIXME comment
  void handleSendInitializationMessages(CProxy_Region regionProxy);
};

#endif // __FILE_MANAGER_H__
