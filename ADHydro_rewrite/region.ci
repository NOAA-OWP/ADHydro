module region
{
  array [1D] Region
  {
    entry Region(double referenceDateInit, double currentTimeInit, double simulationEndTimeInit);
    
    entry void runUntilSimulationEnd()
    {
      // FIXME do initialization.
      
      // Do an initial mass balance.
      // FIXME decide what to do about this.
      serial
      {
        bool   error                = false;
        double massBalanceValues[3] = {0.0, 0.0, 0.0};
        
        error = massBalance(massBalanceValues[0], massBalanceValues[1], massBalanceValues[2]);
        
        if (!error)
          {
            contribute(3 * sizeof(double), massBalanceValues, CkReduction::sum_double);
          }
        else
          {
            CkExit();
          }
      }
      
      while (currentTime < simulationEndTime)
      {
        // Step 1: Calculate nominal flow rates with neighbors.
        serial
        {
          sendStateToExternalNeighbors();
        }
        
        // Continue step 1 by calculating nominal flow rates with internal neighbors.
        when calculateNominalFlowRatesForInternalNeighbors()
        {
          serial
          {
            handleCalculateNominalFlowRatesForInternalNeighbors();
          }
        }
        
        // Finish step 1 by receiving state messages until all nominal flow rates are calculated.
        // Step 2: Select timestep is accomplished while scanning to see if all nominal flow rates are calculated.  That scan also finds the minimum expiration
        // time, which is chosen as the next timestep end time.
        while (!allNominalFlowRatesCalculated())
        {
          when sendStateMessages(double senderCurrentTime, double senderRegionalDtLimit, std::vector<RegionMessageStruct> stateMessages)
          {
            serial
            {
              processStateMessages(senderCurrentTime, senderRegionalDtLimit, stateMessages);
            }
          }
        }
        
        // Step 3: Send outflows of material to neighbors.
        serial
        {
          doPointProcessesAndSendOutflows();
        }
        
        // Step 4: Receive inflows of material from neighbors.
        while (!allInflowsArrived())
        {
          when sendWaterMessages(std::vector<RegionMessageStruct> waterMessages)
          {
            serial
            {
              processWaterMessages(waterMessages);
            }
          }
        }
        
        // Finish step 4 by moving water from incoming material lists to element state variables.
        // Step 5: Advance time.
        serial
        {
          receiveInflowsAndAdvanceTime();
        }
        
        // FIXME do output.
        
        // Do a periodic mass balance.
        // FIXME decide what to do about this.
        // FIXME the last one of these never gets a chance to finish before we call CkExit.
        serial
        {
          if (currentTime == nextSyncTime)
            {
              bool   error                = false;
              double massBalanceValues[3] = {0.0, 0.0, 0.0};
              
              error = massBalance(massBalanceValues[0], massBalanceValues[1], massBalanceValues[2]);
              
              if (!error)
                {
                  contribute(3 * sizeof(double), massBalanceValues, CkReduction::sum_double);
                }
              else
                {
                  CkExit();
                }
              
              nextSyncTime += 100.0;
              
              if (nextSyncTime > simulationEndTime)
                {
                  nextSyncTime = simulationEndTime;
                }
            }
        }
      } // End while (currentTime < simulationEndTime).
      
      serial
      {
        contribute(CkCallback(CkCallback::ckExit));
      }
    }; // End entry void runUntilSimulationEnd();
    
    entry void calculateNominalFlowRatesForInternalNeighbors();
    entry void sendStateMessages(double senderCurrentTime, double senderRegionalDtLimit, std::vector<RegionMessageStruct> stateMessages);
    entry void sendWaterMessages(std::vector<RegionMessageStruct> waterMessages);
  }; // End array [1D] Region.
}; // End module region.
